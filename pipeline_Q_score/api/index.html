<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>번역품질 검사기 | MT Quality Analytics</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* 주식 웹사이트 컬러 팔레트 */
            --primary-bg: #0a0e1a;
            --secondary-bg: #1a1f2e;
            --card-bg: #252d3d;
            --accent-bg: #2a3441;
            --success-color: #00d084;
            --danger-color: #ff6b6b;
            --warning-color: #ffa726;
            --info-color: #42a5f5;
            --neutral-color: #6c757d;
            --text-primary: #ffffff;
            --text-secondary: #b3bcc8;
            --text-muted: #8b949e;
            --border-color: #30374a;
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-medium: rgba(0, 0, 0, 0.25);
            --gradient-success: linear-gradient(135deg, #00d084, #00c477);
            --gradient-danger: linear-gradient(135deg, #ff6b6b, #ff5252);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.6;
            font-size: 14px;
            min-height: 100vh;
        }

        .main-header {
            background: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 24px;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            background: var(--gradient-success);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 14px;
            color: var(--text-muted);
            font-weight: 400;
        }

        .header-stats {
            display: flex;
            gap: 24px;
            align-items: stretch; /* 모든 카드를 같은 높이로 맞춤 */
        }

        .stat-item {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 16px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            width: 160px; /* Q-SCORE 개선도 카드에 맞춰 더 넓게 */
            height: 90px; /* 위아래 글씨를 포함할 수 있도록 높이 증가 */
            flex-shrink: 0; /* 크기 축소 방지 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .stat-item:hover {
            border-color: var(--success-color);
            background: var(--accent-bg);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 208, 132, 0.2);
        }

        .stat-item::before {
            content: '▦';
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--success-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s ease;
        }

        /* Professional Icon Styles */
        .icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            font-size: 14px;
            font-weight: 500;
        }

        .icon-chart::before { content: '■'; color: var(--info-color); }
        .icon-star::before { content: '★'; color: var(--warning-color); }
        .icon-warning::before { content: '⚠'; color: var(--danger-color); }
        .icon-improve::before { content: '▲'; color: var(--success-color); }
        .icon-trend-up::before { content: '▲'; color: var(--success-color); }
        .icon-info::before { 
            content: 'i'; 
            background: var(--info-color); 
            border-radius: 50%; 
            width: 14px; 
            height: 14px; 
            font-size: 10px; 
            font-weight: bold; 
            color: white; 
            text-align: center;
            line-height: 14px;
        }
        .icon-arrow-up::before { content: '▲'; color: var(--text-secondary); }
        .icon-more::before { content: '•••'; color: var(--text-secondary); letter-spacing: 2px; }
        .icon-scale::before { content: '⚖'; color: var(--info-color); }
        .icon-guide::before { content: '≡'; color: var(--info-color); }

        .stat-item:hover::before {
            opacity: 1;
            transform: scale(1);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
        }

        .stat-subtext {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 4px;
            opacity: 0.8;
        }

        .stat-item:hover::before {
            opacity: 1;
            transform: scale(1);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        .sidebar {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            height: fit-content;
        }

        .main-content {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: visible;
            position: relative;
        }

        .nav-section {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .nav-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 4px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .nav-item:hover {
            background: var(--accent-bg);
            color: var(--text-primary);
        }

        .nav-item.active {
            background: var(--success-color);
            color: white;
            font-weight: 500;
        }

        .search-section {
            padding: 20px;
        }

        .search-box {
            position: relative;
            margin-bottom: 16px;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 16px;
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--success-color);
            box-shadow: 0 0 0 3px rgba(0, 208, 132, 0.1);
        }

        input[type="text"]::placeholder {
            color: var(--text-muted);
        }

        .filter-group {
            margin-bottom: 16px;
        }

        .filter-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 12px;
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: var(--success-color);
            color: white;
            border-color: var(--success-color);
        }

        /* 범위 슬라이더 스타일 */
        .range-filter {
            margin-bottom: 16px;
        }

        .range-slider-container {
            position: relative;
            margin: 12px 0;
        }

        .dual-range-slider {
            position: relative;
            height: 6px;
            background: var(--accent-bg);
            border-radius: 3px;
            margin: 20px 0;
        }

        .dual-range-slider input[type="range"] {
            position: absolute;
            width: 100%;
            height: 6px;
            background: transparent;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            pointer-events: none;
        }

        .dual-range-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--success-color);
            cursor: pointer;
            border: 2px solid var(--secondary-bg);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            pointer-events: all;
        }

        .dual-range-slider input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--success-color);
            cursor: pointer;
            border: 2px solid var(--secondary-bg);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            pointer-events: all;
        }

        .range-track {
            position: absolute;
            height: 6px;
            background: var(--success-color);
            border-radius: 3px;
            top: 0;
        }

        .range-values {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 8px;
        }

        .range-current {
            font-size: 12px;
            color: var(--success-color);
            font-weight: 500;
            text-align: center;
            margin-top: 4px;
        }

        .delta-toggle {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .toggle-btn {
            flex: 1;
            padding: 6px 8px;
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .toggle-btn:hover,
        .toggle-btn.active {
            background: var(--success-color);
            color: white;
            border-color: var(--success-color);
        }

        .content-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .view-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .btn {
            padding: 10px 16px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--accent-bg);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--secondary-bg);
            color: var(--text-primary);
            border-color: var(--success-color);
        }

        .btn.primary {
            background: var(--success-color);
            color: white;
            border-color: var(--success-color);
        }

        .btn.primary:hover {
            background: #00c477;
        }

        /* 주식 스타일 레코드 카드 */
        .record-grid {
            padding: 24px;
        }

        .record-card {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: visible;
            transition: all 0.2s;
        }

        .record-card:hover {
            border-color: var(--success-color);
            box-shadow: 0 4px 12px rgba(0, 208, 132, 0.1);
        }

        .record-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .record-id {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            color: var(--text-muted);
            background: var(--accent-bg);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .quality-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .quality-badge-improved {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .quality-badge-original {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            opacity: 0.7;
            position: relative;
        }

        .quality-badge-original::before {
            content: '기존: ';
            font-size: 9px;
            opacity: 0.8;
        }

        .quality-improvement-arrow {
            color: var(--success-color);
            font-size: 14px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .quality-badge-mini {
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            display: inline-block;
        }

        .quality-badge-mini.quality-excellent {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .quality-badge-mini.quality-very-good {
            background: rgba(132, 204, 22, 0.2);
            color: #84cc16;
            border: 1px solid rgba(132, 204, 22, 0.3);
        }

        .quality-badge-mini.quality-good {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .quality-badge-mini.quality-poor {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .quality-badge-mini.quality-very-poor {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .quality-excellent {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .quality-very-good {
            background: rgba(132, 204, 22, 0.2);
            color: #84cc16;
            border: 1px solid rgba(132, 204, 22, 0.3);
        }

        .quality-good {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .quality-poor {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .quality-very-poor {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        /* 주식 스타일 점수 섹션 */
        .scores-section {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        .score-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
        }

        .score-card:hover {
            border-color: var(--success-color);
            transform: translateY(-2px);
        }

        .score-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--neutral-color);
        }

        .score-card.improvement::before {
            background: var(--gradient-success);
        }

        .score-card.decline::before {
            background: var(--gradient-danger);
        }

        .score-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .score-main {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .score-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .score-change {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            font-weight: 600;
        }

        .score-arrow {
            font-size: 16px;
        }

        .score-positive {
            color: var(--success-color);
        }

        .score-negative {
            color: var(--danger-color);
        }

        .score-neutral {
            color: var(--neutral-color);
        }

        .score-percentage {
            font-size: 12px;
            color: var(--text-muted);
        }

        .score-gauge {
            height: 4px;
            background: var(--accent-bg);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 12px;
        }

        .score-fill {
            height: 100%;
            background: var(--success-color);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* 텍스트 diff 스타일 */
        .text-section {
            padding: 20px;
            border-top: 1px solid var(--border-color);
        }

        .text-row {
            margin-bottom: 16px;
        }

        .text-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .text-content {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-primary);
        }

        .text-diff {
            position: relative;
        }

        .diff-original {
            background: rgba(255, 107, 107, 0.15);
            color: #ff8a80;
            padding: 2px 4px;
            border-radius: 3px;
            text-decoration: line-through;
            margin-right: 4px;
        }

        .diff-improved {
            background: rgba(0, 208, 132, 0.15);
            color: #4ade80;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 500;
        }

        /* APE 개선 표시 */
        .ape-improvement {
            background: var(--card-bg);
            border: 1px solid rgba(0, 208, 132, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-top: 12px;
        }

        .ape-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .ape-icon {
            color: var(--success-color);
            font-size: 16px;
        }

        .ape-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--success-color);
        }

        /* 툴팁 스타일 */
        .tooltip {
            position: absolute;
            background: var(--secondary-bg);
            color: var(--text-primary);
            padding: 16px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            max-width: 320px;
            line-height: 1.4;
        }

        .tooltip.show {
            opacity: 1;
            visibility: visible;
        }

        .tooltip-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--success-color);
        }

        .tooltip-section {
            margin-bottom: 8px;
        }

        .tooltip-label {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tooltip-value {
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        /* Evidence 표시 스타일 */
        .evidence-indicator {
            position: relative;
            display: inline-block;
            margin-left: 8px;
            cursor: pointer;
        }

        .evidence-icon {
            background: var(--warning-color);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .evidence-icon.critical {
            background: var(--danger-color);
        }

        .evidence-icon.info {
            background: var(--info-color);
        }

        .evidence-tooltip {
            position: fixed;
            background: var(--secondary-bg);
            color: var(--text-primary);
            padding: 16px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            min-width: 200px;
            max-width: 400px;
            width: auto;
            word-wrap: break-word;
            white-space: normal;
            line-height: 1.4;
            pointer-events: none;
        }

        .evidence-tooltip.show {
            opacity: 1;
            visibility: visible;
        }

        .score-info-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 12px;
            margin-left: 4px;
            transition: color 0.2s;
        }

        .score-info-btn:hover {
            color: var(--success-color);
        }

        .load-more-section {
            padding: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid var(--border-color);
            background: var(--secondary-bg);
            position: relative;
        }

        .load-more-section .btn.primary {
            position: absolute;
            bottom: 24px;
            right: 24px;
            border-radius: 50px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 100;
            font-size: 14px;
            padding: 12px 20px;
        }

        .scroll-to-top {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            color: var(--text-muted);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 99;
            opacity: 0;
            visibility: hidden;
        }

        .scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .scroll-to-top:hover {
            background: var(--success-color);
            color: white;
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 208, 132, 0.3);
        }

        .record-count-info {
            margin-top: 12px;
            font-size: 13px;
            color: var(--text-muted);
            text-align: center;
            flex: 1;
        }

        .record-count-info span {
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* 스크롤 투 탑 버튼 */
        .scroll-to-top {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            color: var(--text-muted);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 99;
            opacity: 0;
            visibility: hidden;
        }

        .scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .scroll-to-top:hover {
            background: var(--success-color);
            color: white;
            transform: translateX(-50%) translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 208, 132, 0.3);
        }

        /* 통계 차트 모달 */
        .stats-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .stats-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .stats-modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 32px;
            max-width: 800px;
            width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        .stats-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .stats-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stats-modal-close {
            background: transparent;
            border: none;
            font-size: 24px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .stats-modal-close:hover {
            background: var(--accent-bg);
            color: var(--text-primary);
        }

        /* 스코어 정보 모달 */
        .score-info-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .score-info-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .score-info-modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 0;
            max-width: 600px;
            width: 90%;
            max-height: 85%;
            overflow: hidden;
            position: relative;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .score-info-header {
            background: linear-gradient(135deg, var(--success-color), #4ade80);
            color: white;
            padding: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-info-title {
            font-size: 24px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .score-info-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .score-info-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .score-info-body {
            padding: 24px;
            overflow-y: auto;
            max-height: 60vh;
        }

        .score-current-value {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-bottom: 24px;
        }

        .score-current-value .value {
            font-size: 36px;
            font-weight: 700;
            color: var(--success-color);
            margin-bottom: 8px;
        }

        .score-current-value .label {
            font-size: 14px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .score-section {
            margin-bottom: 24px;
        }

        .score-section-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .score-section-content {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .score-improvement-info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(34, 197, 94, 0.1));
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
        }

        .score-improvement-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--info-color);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .score-improvement-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
        }

        .score-improvement-item {
            text-align: center;
        }

        .score-improvement-item .value {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .score-improvement-item .value.positive {
            color: var(--success-color);
        }

        .score-improvement-item .value.negative {
            color: var(--error-color);
        }

        .score-improvement-item .label {
            font-size: 12px;
            color: var(--text-muted);
        }

        .quality-scale {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }

        .quality-scale-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .quality-scale-item:last-child {
            border-bottom: none;
        }

        .quality-scale-range {
            font-weight: 600;
            color: var(--text-primary);
        }

        .quality-scale-description {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .chart-container {
            width: 100%;
            height: 400px;
            margin-bottom: 24px;
            position: relative;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .chart-stat {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            min-height: 100px; 
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .chart-stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--success-color);
            margin-bottom: 8px;
        }

        .chart-stat-label {
            font-size: 14px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.2;
            text-align: center;
        }

        .chart-stat-desc {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 8px;
            line-height: 1.4;
        }


        .simple-chart {
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            height: 320px;
            padding: 24px 20px 40px 20px; 
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            gap: 20px;
            position: relative;
        }

        .chart-bar {
            display: flex;
            flex-direction: column;
            align-self: flex-end;
            align-items: center;
            max-width: 120px; 
            flex: 1;
            position: relative;
        }

        .bar {
            width: 100%;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 8px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.2);
            min-height: 0; 
        }

        .bar:hover {
            opacity: 0.9;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
        }

        .bar-value {
            color: white;
            font-size: 13px;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0,0,0,0.7);
            background: rgba(0,0,0,0.3);
            padding: 4px 8px;
            border-radius: 4px;
            backdrop-filter: blur(2px);
            white-space: nowrap;
        }

        .bar-label {
            font-size: 12px;
            color: var(--text-primary);
            text-align: center;
            font-weight: 500;
            line-height: 1.2;
            position: absolute;
            bottom: -35px; /* 라벨을 바 아래로 위치 */
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
        }

        /* 도넛 차트 스타일 */
        .donut-chart {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 300px;
            position: relative;
        }

        .donut-svg {
            width: 200px;
            height: 200px;
        }

        .donut-legend {
            margin-left: 40px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            margin-right: 12px;
        }

        .legend-label {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .legend-value {
            font-size: 12px;
            color: var(--text-muted);
            margin-left: auto;
        }

        /* 새로운 품질 차트 카드 스타일 */
        .quality-comparison-container {
            margin: 24px 0;
        }

        .quality-chart-card {
            transition: all 0.3s ease;
            border-radius: 12px;
        }

        .quality-chart-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.12) !important;
        }

        .quality-legend-simplified {
            transition: all 0.3s ease;
        }

        .legend-item-compact {
            transition: all 0.25s ease;
            cursor: default;
        }

        .legend-item-compact:hover {
            transform: translateY(-1px);
        }

        .donut-tooltip {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, system-ui, sans-serif;
            white-space: nowrap;
            max-width: 280px;
            line-height: 1.4;
        }

        /* 반응형 디자인 */
        @media (max-width: 1024px) {
            .quality-comparison-container > div:first-child {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            
            .legend-inline {
                gap: 20px !important;
            }
        }

        @media (max-width: 768px) {
            .quality-chart-card {
                padding: 16px;
            }
            
            .quality-legend-simplified {
                padding: 16px;
            }
            
            .legend-inline {
                gap: 16px !important;
                justify-content: center !important;
            }
            
            .legend-item-compact {
                flex-shrink: 0;
            }
            
            .donut-tooltip {
                font-size: 12px !important;
                padding: 10px 12px !important;
                max-width: 220px;
            }
        }

        @media (max-width: 480px) {
            .legend-inline {
                flex-direction: column;
                align-items: center;
                gap: 12px !important;
            }
            
            .legend-item-compact {
                justify-content: center;
            }
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .scores-section {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
            
            .header-stats {
                gap: 12px;
            }
            
            .stat-item {
                width: 100px; /* 모바일에서도 Q-SCORE 개선도에 맞춰 조정 */
                height: 80px; /* 모바일 고정 높이 증가 */
                flex-shrink: 0;
                padding: 12px 16px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }
            
            .stat-value {
                font-size: 20px;
            }
            
            .stat-label {
                font-size: 10px;
            }
            
            .stat-subtext {
                font-size: 8px;
            }

            .stats-modal-content {
                margin: 20px;
                padding: 20px;
                max-width: none;
                width: auto;
            }

            .chart-grid {
                grid-template-columns: repeat(2, 1fr); /* 모바일에서는 2열로 */
                gap: 12px;
            }

            .donut-chart {
                flex-direction: column;
                height: auto;
            }

            .donut-legend {
                margin-left: 0;
                margin-top: 20px;
            }
        }

        /* 매우 작은 화면 (480px 이하) */
        @media (max-width: 480px) {
            .chart-grid {
                grid-template-columns: 1fr; /* 매우 작은 화면에서는 1열로 */
                gap: 8px;
            }

            .chart-stat {
                padding: 16px;
                min-height: 80px;
            }

            .chart-stat-value {
                font-size: 20px;
            }

            .chart-stat-label {
                font-size: 12px;
            }
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--accent-bg);
            border-top: 3px solid var(--success-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <header class="main-header">
        <div class="header-content">
            <div class="logo-section">
                <div class="logo" onclick="location.reload()" style="cursor: pointer;">번역품질 검사기</div>
                <div class="subtitle">MT Quality Analytics</div>
            </div>
            <div class="header-stats" id="headerStats">
                <div class="stat-item" onclick="showStatsChart('records')">
                    <div class="stat-label">총 레코드</div>
                    <div class="stat-value" id="totalRecords">-</div>
                    <div class="stat-subtext">클릭하여 차트 보기</div>
                </div>
                <div class="stat-item" onclick="showStatsChart('pass-rate')">
                    <div class="stat-label">통과율</div>
                    <div class="stat-value" id="passRate">-</div>
                    <div class="stat-subtext">클릭하여 차트 보기</div>
                </div>
                <div class="stat-item" onclick="showStatsChart('ape-effect')">
                    <div class="stat-label">개선도</div>
                    <div class="stat-value" id="apeEffectiveness">-</div>
                    <div class="stat-subtext">클릭하여 차트 보기</div>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="dashboard-grid">
            <aside class="sidebar">
                <div class="nav-section">
                    <div class="nav-title">분석 도구</div>
                    <div class="nav-item active" data-view="all">
                        <span class="icon icon-chart"></span> 전체 데이터
                    </div>
                    <div class="nav-item" data-view="high-quality">
                        <span class="icon icon-star"></span> 고품질 번역
                    </div>
                    <div class="nav-item" data-view="failed">
                        <span class="icon icon-warning"></span> 품질 미달
                    </div>
                    <div class="nav-item" data-view="ape-improved">
                        <span class="icon icon-improve"></span> APE 개선사례
                    </div>
                </div>

                <div class="search-section">
                    <div class="search-box">
                        <select id="searchType" style="width: 100%; padding: 8px 12px; background: var(--accent-bg); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; margin-bottom: 8px;">
                            <option value="all">전체 필드 검색</option>
                            <option value="key">Key 검색</option>
                            <option value="src">원문 검색</option>
                            <option value="mt">기계번역 검색</option>
                            <option value="ape">APE 검색</option>
                        </select>
                        <input type="text" id="searchInput" placeholder="검색어를 입력하세요...">
                    </div>
                    
                    <!-- 필터 초기화 버튼 -->
                    <div style="margin-bottom: 16px; display: flex; justify-content: flex-end;">
                        <button onclick="resetAllFilters()" style="width: 24px; height: 24px; padding: 0; background: var(--accent-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; transition: all 0.2s;" onmouseover="this.style.background='var(--success-color)'; this.style.color='white';" onmouseout="this.style.background='var(--accent-bg)'; this.style.color='var(--text-secondary)';" title="모든 필터 초기화">
                            ↻
                        </button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">품질 등급</label>
                        <div class="filter-buttons">
                            <button class="filter-btn active" data-filter="all">전체</button>
                            <button class="filter-btn" data-filter="excellent">매우우수</button>
                            <button class="filter-btn" data-filter="very-good">우수</button>
                            <button class="filter-btn" data-filter="good">양호</button>
                            <button class="filter-btn" data-filter="poor">나쁨</button>
                            <button class="filter-btn" data-filter="very-poor">매우나쁨</button>
                        </div>
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">텍스트 길이</label>
                        <div class="filter-buttons">
                            <button class="filter-btn active" data-bucket="all">전체</button>
                            <button class="filter-btn" data-bucket="very_short">매우짧음</button>
                            <button class="filter-btn" data-bucket="short">짧음</button>
                            <button class="filter-btn" data-bucket="medium">보통</button>
                            <button class="filter-btn" data-bucket="long">김</button>
                            <button class="filter-btn" data-bucket="very_long">매우김</button>
                        </div>
                    </div>

                    <div class="range-filter">
                        <label class="filter-label">GEMBA 점수</label>
                        <div class="range-slider-container">
                            <div class="dual-range-slider">
                                <div class="range-track" id="gembaTrack"></div>
                                <input type="range" id="gembaMin" min="0" max="100" value="0" step="1">
                                <input type="range" id="gembaMax" min="0" max="100" value="100" step="1">
                            </div>
                            <div class="range-values">
                                <span>0</span>
                                <span>100</span>
                            </div>
                            <div class="range-current" id="gembaRangeCurrent">전체 범위 (0 ~ 100)</div>
                        </div>
                    </div>

                    <div class="range-filter">
                        <label class="filter-label">COMET 점수</label>
                        <div class="range-slider-container">
                            <div class="dual-range-slider">
                                <div class="range-track" id="cometTrack"></div>
                                <input type="range" id="cometMin" min="0" max="100" value="0" step="1">
                                <input type="range" id="cometMax" min="0" max="100" value="100" step="1">
                            </div>
                            <div class="range-values">
                                <span>0.0</span>
                                <span>1.0</span>
                            </div>
                            <div class="range-current" id="cometRangeCurrent">전체 범위 (0.00 ~ 1.00)</div>
                        </div>
                    </div>

                    <div class="range-filter">
                        <label class="filter-label">COS 점수</label>
                        <div class="range-slider-container">
                            <div class="dual-range-slider">
                                <div class="range-track" id="cosTrack"></div>
                                <input type="range" id="cosMin" min="0" max="100" value="0" step="1">
                                <input type="range" id="cosMax" min="0" max="100" value="100" step="1">
                            </div>
                            <div class="range-values">
                                <span>0.0</span>
                                <span>1.0</span>
                            </div>
                            <div class="range-current" id="cosRangeCurrent">전체 범위 (0.00 ~ 1.00)</div>
                        </div>
                    </div>

                    <div class="range-filter">
                        <label class="filter-label">개선도</label>
                        <div class="delta-toggle">
                            <button class="toggle-btn active" data-delta="comet">COMET 개선</button>
                            <button class="toggle-btn" data-delta="cos">COS 개선</button>
                        </div>
                        <div class="range-slider-container">
                            <div class="dual-range-slider">
                                <div class="range-track" id="deltaTrack"></div>
                                <input type="range" id="deltaMin" min="-50" max="50" value="-50" step="1">
                                <input type="range" id="deltaMax" min="-50" max="50" value="50" step="1">
                            </div>
                            <div class="range-values">
                                <span>-0.5</span>
                                <span>+0.5</span>
                            </div>
                            <div class="range-current" id="deltaRangeCurrent">전체 범위 (-0.50 ~ +0.50)</div>
                        </div>
                    </div>
                </div>
            </aside>

            <main class="main-content">
                <div class="content-header">
                    <div class="content-title" id="contentTitle">전체 번역품질 현황</div>
                    <div class="view-controls">
                        <button class="btn" onclick="refreshData()">
                            <span>↻</span> 새로고침
                        </button>
                        <button class="btn primary" onclick="exportData()">
                            <span>⬇</span> 데이터 내보내기
                        </button>
                    </div>
                </div>

                <div class="record-grid" id="recordGrid">
                    <div class="loading">
                        <div class="spinner"></div>
                        데이터를 불러오는 중...
                    </div>
                </div>

                <div id="loadMoreSection" class="load-more-section" style="display: none;">
                    <div class="record-count-info">
                        현재 <span id="currentCount">0</span>개 / 전체 <span id="totalCount">0</span>개 표시중
                    </div>
                    <button class="btn primary" id="loadMoreBtn" onclick="loadMoreRecords()">
                        <span class="icon icon-more"></span> 더보기
                    </button>
                </div>
            </main>
        </div>
    </div>

    <!-- 스크롤 투 탑 버튼 -->
    <div class="scroll-to-top" id="scrollToTop" onclick="scrollToTop()">
        <span class="icon icon-arrow-up"></span>
    </div>

    <!-- 통계 차트 모달 -->
    <div class="stats-modal" id="statsModal">
        <div class="stats-modal-content">
            <div class="stats-modal-header">
                <div class="stats-modal-title" id="modalTitle">통계 분석</div>
                <button class="stats-modal-close" onclick="closeStatsModal()">×</button>
            </div>
            <div id="modalContent">
                <!-- 차트 내용이 여기에 동적으로 삽입됩니다 -->
            </div>
        </div>
    </div>

    <!-- 스코어 정보 모달 -->
    <div class="score-info-modal" id="scoreInfoModal">
        <div class="score-info-modal-content">
            <div class="score-info-header">
                <div class="score-info-title">
                    <span class="icon icon-chart"></span> <span id="scoreModalTitle">점수 상세 정보</span>
                </div>
                <button class="score-info-close" onclick="closeScoreInfoModal()">×</button>
            </div>
            <div class="score-info-body">
                <div class="score-current-value">
                    <div class="value" id="scoreCurrentValue">-</div>
                    <div class="label" id="scoreCurrentLabel">점수</div>
                </div>

                <div class="score-improvement-info" id="scoreImprovementInfo" style="display: none;">
                    <div class="score-improvement-title">
                        <span class="icon icon-trend-up"></span> 개선 분석 결과
                    </div>
                    <div class="score-improvement-details">
                        <div class="score-improvement-item">
                            <div class="value" id="deltaValue">-</div>
                            <div class="label">개선 정도</div>
                        </div>
                        <div class="score-improvement-item">
                            <div class="value" id="beforeValue">-</div>
                            <div class="label">원본 점수</div>
                        </div>
                        <div class="score-improvement-item">
                            <div class="value" id="afterValue">-</div>
                            <div class="label">개선 후 점수</div>
                        </div>
                    </div>
                </div>

                <div class="score-section">
                    <div class="score-section-title">
                        <span class="icon icon-scale"></span> 품질 평가 기준
                    </div>
                    <div class="score-section-content">
                        <div class="quality-scale" id="qualityScale">
                            <!-- 품질 기준이 여기에 동적으로 추가됩니다 -->
                        </div>
                    </div>
                </div>

                <div class="score-section">
                    <div class="score-section-title">
                        <span class="icon icon-guide"></span> 점수 해석 가이드
                    </div>
                    <div class="score-section-content" id="scoreInterpretation">
                        <!-- 점수 해석 내용이 여기에 동적으로 추가됩니다 -->
                    </div>
                </div>

                <div class="score-section">
                    <div class="score-section-title">
                        <span class="icon icon-info"></span> 평가 방법
                    </div>
                    <div class="score-section-content" id="evaluationMethod">
                        <!-- 평가 방법 설명이 여기에 동적으로 추가됩니다 -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';
        let currentData = [];
        let allData = []; // 전체 데이터 저장
        let displayLimit = 10; // 현재 표시 개수
        let currentFilters = {
            view: 'all',
            quality: 'all',
            bucket: 'all',
            search: '',
            searchType: 'all',
            ranges: {
                gemba: { min: 0, max: 100, enabled: false },
                comet: { min: 0, max: 1, enabled: false },
                cos: { min: 0, max: 1, enabled: false },
                delta: { min: -0.5, max: 0.5, enabled: false, type: 'comet' }
            }
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            loadHeaderStats();
            loadRecords();
            setupEventListeners();
            setupScrollToTop();
        });

        function setupScrollToTop() {
            const scrollToTopBtn = document.getElementById('scrollToTop');
            
            window.addEventListener('scroll', function() {
                if (window.pageYOffset > 300) {
                    scrollToTopBtn.classList.add('visible');
                } else {
                    scrollToTopBtn.classList.remove('visible');
                }
            });
        }

        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        function setupEventListeners() {
            // 내비게이션 아이템
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                    currentFilters.view = this.dataset.view;
                    updateContentTitle();
                    resetPagination();
                    loadRecords();
                });
            });

            // 필터 버튼들
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const group = this.parentElement;
                    group.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    if (this.dataset.filter) {
                        currentFilters.quality = this.dataset.filter;
                    }
                    if (this.dataset.bucket) {
                        currentFilters.bucket = this.dataset.bucket;
                    }
                    
                    resetPagination();
                    loadRecords();
                });
            });

            // 검색
            document.getElementById('searchInput').addEventListener('input', function() {
                currentFilters.search = this.value;
                currentFilters.searchType = document.getElementById('searchType').value;
                resetPagination();
                debounce(loadRecords, 300)();
            });

            document.getElementById('searchType').addEventListener('change', function() {
                currentFilters.searchType = this.value;
                if (currentFilters.search) {
                    resetPagination();
                    loadRecords();
                }
            });

            // 범위 슬라이더 이벤트
            setupRangeSliders();
        }

        function setupRangeSliders() {
            // GEMBA 듀얼 레인지 슬라이더
            const gembaMin = document.getElementById('gembaMin');
            const gembaMax = document.getElementById('gembaMax');
            const gembaTrack = document.getElementById('gembaTrack');
            
            function updateGembaRange() {
                let minVal = parseInt(gembaMin.value);
                let maxVal = parseInt(gembaMax.value);
                
                if (minVal > maxVal) {
                    [minVal, maxVal] = [maxVal, minVal];
                    gembaMin.value = minVal;
                    gembaMax.value = maxVal;
                }
                
                currentFilters.ranges.gemba.min = minVal;
                currentFilters.ranges.gemba.max = maxVal;
                currentFilters.ranges.gemba.enabled = minVal > 0 || maxVal < 100;
                
                // 트랙 업데이트
                const minPercent = (minVal / 100) * 100;
                const maxPercent = (maxVal / 100) * 100;
                gembaTrack.style.left = minPercent + '%';
                gembaTrack.style.width = (maxPercent - minPercent) + '%';
                
                document.getElementById('gembaRangeCurrent').textContent = 
                    currentFilters.ranges.gemba.enabled ? `범위: ${minVal} ~ ${maxVal}점` : '전체 범위 (0 ~ 100)';
                
                debounce(loadRecordsWithReset, 300)();
            }
            
            gembaMin.addEventListener('input', updateGembaRange);
            gembaMax.addEventListener('input', updateGembaRange);
            updateGembaRange(); // 초기화

            // COMET 듀얼 레인지 슬라이더
            const cometMin = document.getElementById('cometMin');
            const cometMax = document.getElementById('cometMax');
            const cometTrack = document.getElementById('cometTrack');
            
            function updateCometRange() {
                let minVal = parseInt(cometMin.value);
                let maxVal = parseInt(cometMax.value);
                
                if (minVal > maxVal) {
                    [minVal, maxVal] = [maxVal, minVal];
                    cometMin.value = minVal;
                    cometMax.value = maxVal;
                }
                
                const minScore = minVal / 100;
                const maxScore = maxVal / 100;
                
                currentFilters.ranges.comet.min = minScore;
                currentFilters.ranges.comet.max = maxScore;
                currentFilters.ranges.comet.enabled = minVal > 0 || maxVal < 100;
                
                // 트랙 업데이트
                const minPercent = (minVal / 100) * 100;
                const maxPercent = (maxVal / 100) * 100;
                cometTrack.style.left = minPercent + '%';
                cometTrack.style.width = (maxPercent - minPercent) + '%';
                
                document.getElementById('cometRangeCurrent').textContent = 
                    currentFilters.ranges.comet.enabled ? `범위: ${minScore.toFixed(2)} ~ ${maxScore.toFixed(2)}` : '전체 범위 (0.00 ~ 1.00)';
                
                debounce(loadRecordsWithReset, 300)();
            }
            
            cometMin.addEventListener('input', updateCometRange);
            cometMax.addEventListener('input', updateCometRange);
            updateCometRange(); // 초기화

            // COS 듀얼 레인지 슬라이더
            const cosMin = document.getElementById('cosMin');
            const cosMax = document.getElementById('cosMax');
            const cosTrack = document.getElementById('cosTrack');
            
            function updateCosRange() {
                let minVal = parseInt(cosMin.value);
                let maxVal = parseInt(cosMax.value);
                
                if (minVal > maxVal) {
                    [minVal, maxVal] = [maxVal, minVal];
                    cosMin.value = minVal;
                    cosMax.value = maxVal;
                }
                
                const minScore = minVal / 100;
                const maxScore = maxVal / 100;
                
                currentFilters.ranges.cos.min = minScore;
                currentFilters.ranges.cos.max = maxScore;
                currentFilters.ranges.cos.enabled = minVal > 0 || maxVal < 100;
                
                // 트랙 업데이트
                const minPercent = (minVal / 100) * 100;
                const maxPercent = (maxVal / 100) * 100;
                cosTrack.style.left = minPercent + '%';
                cosTrack.style.width = (maxPercent - minPercent) + '%';
                
                document.getElementById('cosRangeCurrent').textContent = 
                    currentFilters.ranges.cos.enabled ? `범위: ${minScore.toFixed(2)} ~ ${maxScore.toFixed(2)}` : '전체 범위 (0.00 ~ 1.00)';
                
                debounce(loadRecordsWithReset, 300)();
            }
            
            cosMin.addEventListener('input', updateCosRange);
            cosMax.addEventListener('input', updateCosRange);
            updateCosRange(); // 초기화

            // Delta 듀얼 레인지 슬라이더
            const deltaMin = document.getElementById('deltaMin');
            const deltaMax = document.getElementById('deltaMax');
            const deltaTrack = document.getElementById('deltaTrack');
            
            function updateDeltaRange() {
                let minVal = parseInt(deltaMin.value);
                let maxVal = parseInt(deltaMax.value);
                
                if (minVal > maxVal) {
                    [minVal, maxVal] = [maxVal, minVal];
                    deltaMin.value = minVal;
                    deltaMax.value = maxVal;
                }
                
                const minScore = minVal / 100;
                const maxScore = maxVal / 100;
                
                currentFilters.ranges.delta.min = minScore;
                currentFilters.ranges.delta.max = maxScore;
                currentFilters.ranges.delta.enabled = minVal > -50 || maxVal < 50;
                
                // 트랙 업데이트 (음수 범위 고려)
                const minPercent = ((minVal + 50) / 100) * 100;
                const maxPercent = ((maxVal + 50) / 100) * 100;
                deltaTrack.style.left = minPercent + '%';
                deltaTrack.style.width = (maxPercent - minPercent) + '%';
                
                document.getElementById('deltaRangeCurrent').textContent = 
                    currentFilters.ranges.delta.enabled ? 
                    `범위: ${minScore >= 0 ? '+' : ''}${minScore.toFixed(2)} ~ ${maxScore >= 0 ? '+' : ''}${maxScore.toFixed(2)}` : 
                    '전체 범위 (-0.50 ~ +0.50)';
                
                debounce(loadRecordsWithReset, 300)();
            }
            
            deltaMin.addEventListener('input', updateDeltaRange);
            deltaMax.addEventListener('input', updateDeltaRange);
            updateDeltaRange(); // 초기화

            // Delta 타입 토글
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentFilters.ranges.delta.type = this.dataset.delta;
                    if (currentFilters.ranges.delta.enabled) {
                        loadRecordsWithReset();
                    }
                });
            });
        }

        function loadRecordsWithReset() {
            resetPagination();
            loadRecords();
        }

        function resetAllFilters() {
            // 페이지 새로고침으로 모든 설정을 완전히 초기화
            location.reload();
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function updateContentTitle() {
            const titles = {
                'all': '전체 번역품질 현황',
                'high-quality': '고품질 번역 (매우우수 + 우수)',
                'failed': '품질 미달 번역 분석 (나쁨 + 매우나쁨)',
                'ape-improved': 'APE 개선 효과 분석'
            };
            
            document.getElementById('contentTitle').textContent = titles[currentFilters.view] || '번역품질 분석';
        }

        function resetPagination() {
            displayLimit = 10;
            allData = [];
        }

        async function loadHeaderStats() {
            try {
                const response = await fetch(`${API_BASE}/analytics`);
                const data = await response.json();
                
                document.getElementById('totalRecords').textContent = data.total_records.toLocaleString();
                
                // APE 적용 후 통과율 사용
                const qualityDist = data.quality_distribution || {};
                const afterDist = qualityDist.after || {};
                const total = data.total_records;
                
                // 개선 후 통과율 (양호 이상 = good + very_good + excellent)
                const afterGood = afterDist.good || 0;
                const afterVeryGood = afterDist.very_good || 0; 
                const afterExcellent = afterDist.excellent || 0;
                const afterPassRate = total > 0 ? (((afterGood + afterVeryGood + afterExcellent) / total) * 100) : 0;
                
                document.getElementById('passRate').textContent = afterPassRate.toFixed(1) + '%';
                
                // Q-score 평균 개선도 사용 (백분율로 표시)
                const apeData = data.ape_effectiveness || {};
                const qScoreImprovement = apeData.avg_q_score_improvement || 0;
                const qScoreImprovementPercent = qScoreImprovement * 100; // 백분율로 변환
                document.getElementById('apeEffectiveness').textContent = 
                    (qScoreImprovementPercent > 0 ? '+' : '') + qScoreImprovementPercent.toFixed(1) + '%';
            } catch (error) {
                console.error('헤더 통계 로드 실패:', error);
            }
        }

        async function loadRecords() {
            const grid = document.getElementById('recordGrid');
            grid.innerHTML = '<div class="loading"><div class="spinner"></div>데이터를 불러오는 중...</div>';

            try {
                let url = `${API_BASE}/records?limit=10000`; // 모든 APE 데이터를 가져옴
                
                // 뷰별 필터링 - 개선 후 품질 등급 기준으로 클라이언트에서 필터링
                // API에서는 모든 데이터를 가져오고, 클라이언트에서 개선 후 품질 등급으로 필터링
                switch (currentFilters.view) {
                    case 'ape-improved':
                        url += '&has_ape=true';
                        break;
                    // high-quality와 failed는 클라이언트에서 개선 후 품질 등급으로 필터링
                }

                // 추가 필터링
                if (currentFilters.bucket !== 'all') {
                    url += `&bucket=${currentFilters.bucket}`;
                }

                const response = await fetch(url);
                const data = await response.json();
                allData = data.records; // 전체 데이터 저장

                // 품질 등급 필터 적용
                if (currentFilters.quality !== 'all') {
                    allData = allData.filter(record => {
                        // APE 개선이 있는 경우 개선 후 품질로 필터링
                        const hasApe = record.ape && record.ape !== record.mt && 
                                      (record.delta_comet || record.delta_cos);
                        
                        let qualityClass;
                        if (hasApe) {
                            // 개선 후 점수로 품질 계산 (APE Q-score 우선 사용)
                            const improvedGemba = record.gemba + (record.delta_gemba || 0);
                            const improvedComet = record.comet + (record.delta_comet || 0);
                            const improvedCos = record.cos + (record.delta_cos || 0);
                            const apeQScore = record.ape_q_score;
                            const apeTag = record.ape_tag;
                            qualityClass = getQualityClassByScores(improvedGemba, improvedComet, improvedCos, apeQScore, apeTag);
                        } else {
                            // 개선이 없는 경우 원래 품질
                            qualityClass = getQualityClass(record);
                        }
                        
                        const qualityMap = {
                            'excellent': 'quality-excellent',
                            'very-good': 'quality-very-good', 
                            'good': 'quality-good',
                            'poor': 'quality-poor',
                            'very-poor': 'quality-very-poor'
                        };
                        return qualityClass === qualityMap[currentFilters.quality];
                    });
                }

                // 뷰별 필터링 - 개선 후 품질 등급 기준
                if (currentFilters.view === 'high-quality' || currentFilters.view === 'failed') {
                    allData = allData.filter(record => {
                        // APE 개선이 있는 경우 개선 후 품질로 필터링
                        const hasApe = record.ape && record.ape !== record.mt && 
                                      (record.delta_comet || record.delta_cos);
                        
                        let qualityClass;
                        if (hasApe) {
                            // 개선 후 점수로 품질 계산 (APE Q-score 우선 사용)
                            const improvedGemba = record.gemba + (record.delta_gemba || 0);
                            const improvedComet = record.comet + (record.delta_comet || 0);
                            const improvedCos = record.cos + (record.delta_cos || 0);
                            const apeQScore = record.ape_q_score;
                            const apeTag = record.ape_tag;
                            qualityClass = getQualityClassByScores(improvedGemba, improvedComet, improvedCos, apeQScore, apeTag);
                        } else {
                            // 개선이 없는 경우 원래 품질
                            qualityClass = getQualityClass(record);
                        }
                        
                        if (currentFilters.view === 'high-quality') {
                            // 고품질: 매우우수 + 우수 등급만
                            return qualityClass === 'quality-excellent' || qualityClass === 'quality-very-good';
                        } else if (currentFilters.view === 'failed') {
                            // 품질미달: 나쁨 + 매우나쁨 등급만 (양호 제외!)
                            return qualityClass === 'quality-poor' || qualityClass === 'quality-very-poor';
                        }
                        return true;
                    });
                }

                // 검색 필터 적용
                if (currentFilters.search) {
                    allData = allData.filter(record => {
                        const searchTerm = currentFilters.search.toLowerCase();
                        const searchType = currentFilters.searchType || 'all';
                        
                        switch(searchType) {
                            case 'key':
                                return (record.key || '').toLowerCase().includes(searchTerm);
                            case 'src':
                                return (record.src || '').toLowerCase().includes(searchTerm);
                            case 'mt':
                                return (record.mt || '').toLowerCase().includes(searchTerm);
                            case 'ape':
                                return (record.ape || '').toLowerCase().includes(searchTerm);
                            case 'all':
                            default:
                                return (record.key || '').toLowerCase().includes(searchTerm) ||
                                       (record.src || '').toLowerCase().includes(searchTerm) ||
                                       (record.mt || '').toLowerCase().includes(searchTerm) ||
                                       (record.ape || '').toLowerCase().includes(searchTerm);
                        }
                    });
                }

                // 범위 필터 적용
                allData = allData.filter(record => {
                    // GEMBA 범위 필터
                    if (currentFilters.ranges.gemba.enabled) {
                        const gembaScore = record.gemba + (record.delta_gemba || 0);
                        if (gembaScore < currentFilters.ranges.gemba.min || 
                            gembaScore > currentFilters.ranges.gemba.max) {
                            return false;
                        }
                    }

                    // COMET 범위 필터
                    if (currentFilters.ranges.comet.enabled) {
                        const cometScore = record.comet + (record.delta_comet || 0);
                        if (cometScore < currentFilters.ranges.comet.min || 
                            cometScore > currentFilters.ranges.comet.max) {
                            return false;
                        }
                    }

                    // COS 범위 필터
                    if (currentFilters.ranges.cos.enabled) {
                        const cosScore = record.cos + (record.delta_cos || 0);
                        if (cosScore < currentFilters.ranges.cos.min || 
                            cosScore > currentFilters.ranges.cos.max) {
                            return false;
                        }
                    }

                    // Delta 범위 필터
                    if (currentFilters.ranges.delta.enabled) {
                        const deltaType = currentFilters.ranges.delta.type;
                        const deltaValue = deltaType === 'comet' ? 
                            (record.delta_comet || 0) : (record.delta_cos || 0);
                        if (deltaValue < currentFilters.ranges.delta.min || 
                            deltaValue > currentFilters.ranges.delta.max) {
                            return false;
                        }
                    }

                    return true;
                });

                // 현재 표시할 데이터 설정
                currentData = allData.slice(0, displayLimit);
                renderRecords(currentData);
                updateLoadMoreSection();
            } catch (error) {
                console.error('데이터 로드 실패:', error);
                grid.innerHTML = '<div class="loading">❌ 데이터 로드에 실패했습니다.</div>';
            }
        }

        function loadMoreRecords() {
            const newLimit = displayLimit + 20;
            currentData = allData.slice(0, newLimit);
            displayLimit = newLimit;
            
            // 기존 레코드 유지하고 새 레코드만 추가
            const grid = document.getElementById('recordGrid');
            const newRecords = allData.slice(displayLimit - 20, displayLimit);
            const newHtml = newRecords.map(record => createRecordCard(record)).join('');
            grid.innerHTML += newHtml;
            
            updateLoadMoreSection();
        }

        function updateLoadMoreSection() {
            const loadMoreSection = document.getElementById('loadMoreSection');
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            const currentCount = document.getElementById('currentCount');
            const totalCount = document.getElementById('totalCount');
            
            const hasMore = displayLimit < allData.length;
            
            if (allData.length > 0) {
                loadMoreSection.style.display = 'block';
                currentCount.textContent = Math.min(displayLimit, allData.length).toLocaleString();
                totalCount.textContent = allData.length.toLocaleString();
                
                if (hasMore) {
                    loadMoreBtn.style.display = 'block';
                    const remaining = allData.length - displayLimit;
                    const nextLoad = Math.min(20, remaining);
                    loadMoreBtn.innerHTML = `<span class="icon icon-more"></span> 더보기 (${nextLoad}개 추가)`;
                } else {
                    loadMoreBtn.style.display = 'none';
                }
            } else {
                loadMoreSection.style.display = 'none';
            }
        }

        function renderRecords(records) {
            const grid = document.getElementById('recordGrid');
            
            if (!records || records.length === 0) {
                grid.innerHTML = '<div class="loading"><span class="icon icon-warning"></span> 표시할 데이터가 없습니다.</div>';
                return;
            }

            const html = records.map(record => createRecordCard(record)).join('');
            grid.innerHTML = html;
        }

        function createRecordCard(record) {
            const hasApe = record.ape && record.ape !== record.mt;

            return `
<div class="record-card">
    <div class="record-header">
        <div class="record-id">${record.key || 'N/A'}</div>
        ${createQualityBadge(record)}
    </div>
    
    <div class="scores-section">
        ${createScoreCard('GEMBA', record.gemba, record.gemba + (record.delta_gemba || 0), 'gemba')}
        ${createScoreCard('COMET', record.comet, record.comet + (record.delta_comet || 0), 'comet')}
        ${createScoreCard('COS', record.cos, record.cos + (record.delta_cos || 0), 'cos')}
    </div>
    
    <div class="text-section">
        <div class="text-row">
            <div class="text-label">원문</div>
            <div class="text-content">${record.src || 'N/A'}</div>
        </div>
        
        <div class="text-row">
            <div class="text-label">기계번역</div>
            <div class="text-content">
                ${record.mt || 'N/A'}
                ${createEvidenceIndicator(record)}
            </div>
        </div>
        
        ${hasApe ? createApeImprovement(record) : ''}
    </div>
</div>
            `;
        }

        function createScoreCard(label, originalScore, improvedScore, type) {
            if (!originalScore && originalScore !== 0) {
                return `
                    <div class="score-card">
                        <div class="score-label">${label}</div>
                        <div class="score-value">N/A</div>
                    </div>
                `;
            }

            const hasImprovement = improvedScore && improvedScore !== originalScore;
            const delta = hasImprovement ? improvedScore - originalScore : 0;
            const deltaPercent = originalScore ? (delta / originalScore * 100) : 0;
            const cardClass = delta > 0 ? 'improvement' : delta < 0 ? 'decline' : '';

            let displayValue = originalScore;
            let changeDisplay = '';

            if (hasImprovement) {
                const arrow = delta > 0 ? '↗' : delta < 0 ? '↘' : '→';
                const changeClass = delta > 0 ? 'score-positive' : delta < 0 ? 'score-negative' : 'score-neutral';
                
                displayValue = improvedScore;
                changeDisplay = `
                    <div class="score-change ${changeClass}">
                        <span class="score-arrow">${arrow}</span>
                        <span>${delta > 0 ? '+' : ''}${type === 'gemba' ? delta.toFixed(0) : delta.toFixed(3)}</span>
                        <span class="score-percentage">(${deltaPercent > 0 ? '+' : ''}${deltaPercent.toFixed(1)}%)</span>
                    </div>
                `;
            }

            const percentage = getScorePercentage(type, displayValue);

            return `
                <div class="score-card ${cardClass}" onclick="showScoreInfo('${type}', ${displayValue}, ${originalScore}, ${delta})">
                    <div class="score-label">
                        ${label}
                        <button class="score-info-btn" onclick="event.stopPropagation(); showScoreInfo('${type}', ${displayValue}, ${originalScore}, ${delta})">ℹ</button>
                    </div>
                    <div class="score-main">
                        <div class="score-value">${type === 'gemba' ? displayValue.toFixed(0) : displayValue.toFixed(3)}</div>
                    </div>
                    ${changeDisplay}
                    <div class="score-gauge">
                        <div class="score-fill" style="width: ${percentage}%"></div>
                    </div>
                </div>
            `;
        }

        function createApeImprovement(record) {
            const textDiff = generateTextDiff(record.mt, record.ape);
            
            // 품질 등급 변화 계산 - APE 개선 전후 비교
            // 개선 전 점수로 원래 품질 계산 (Q-score 기반)
            const originalGemba = record.gemba || 0;
            const originalComet = record.comet || 0;
            const originalCos = record.cos || 0;
            const originalQScore = record.q_score;
            const originalTag = record.tag;
            const originalClass = getQualityClassByScores(originalGemba, originalComet, originalCos, originalQScore, originalTag);
            const originalLabel = getQualityLabelByClass(originalClass);
            
            // 개선 후 점수로 개선된 품질 계산 (APE Q-score 우선 사용)
            const improvedGemba = record.gemba + (record.delta_gemba || 0);
            const improvedComet = record.comet + (record.delta_comet || 0);
            const improvedCos = record.cos + (record.delta_cos || 0);
            const apeQScore = record.ape_q_score;
            const apeTag = record.ape_tag;
            const improvedClass = getQualityClassByScores(improvedGemba, improvedComet, improvedCos, apeQScore, apeTag);
            const improvedLabel = getQualityLabelByClass(improvedClass);
            
            const qualityOrder = {
                'quality-very-poor': 1,
                'quality-poor': 2, 
                'quality-good': 3,
                'quality-very-good': 4,
                'quality-excellent': 5
            };
            
            const isQualityImproved = qualityOrder[improvedClass] > qualityOrder[originalClass];
            
            let qualityChangeInfo = '';
            if (isQualityImproved) {
                qualityChangeInfo = `
<div class="quality-change-info" style="margin-bottom: 12px; padding: 8px; background: rgba(0, 208, 132, 0.1); border-radius: 6px; border-left: 3px solid var(--success-color);">
    <div style="font-size: 11px; color: var(--success-color); font-weight: 600;">품질 등급 개선</div>
    <div style="font-size: 12px; color: var(--text-primary);">
        <span class="quality-badge-mini ${originalClass}">${originalLabel}</span>
        <span style="margin: 0 8px; color: var(--success-color);">→</span>
        <span class="quality-badge-mini ${improvedClass}">${improvedLabel}</span>
    </div>
</div>
                `;
            } else if (originalClass !== improvedClass) {
                // 등급이 바뀌었지만 개선되지 않은 경우도 표시
                qualityChangeInfo = `
<div class="quality-change-info" style="margin-bottom: 12px; padding: 8px; background: rgba(255, 193, 7, 0.1); border-radius: 6px; border-left: 3px solid var(--warning-color);">
    <div style="font-size: 11px; color: var(--warning-color); font-weight: 600;">품질 등급 변화</div>
    <div style="font-size: 12px; color: var(--text-primary);">
        <span class="quality-badge-mini ${originalClass}">${originalLabel}</span>
        <span style="margin: 0 8px; color: var(--warning-color);">→</span>
        <span class="quality-badge-mini ${improvedClass}">${improvedLabel}</span>
    </div>
</div>
                `;
            } else {
                // 등급은 동일하지만 점수가 실제로 개선되었는지 확인
                const gembaImproved = (record.delta_gemba || 0) > 0;
                const cometImproved = (record.delta_comet || 0) > 0;
                const cosImproved = (record.delta_cos || 0) > 0;
                
                // 최소 2개 이상의 메트릭이 개선되었거나, GEMBA가 5점 이상 개선된 경우만 "점수 개선"으로 표시
                const significantImprovement = 
                    (gembaImproved && (record.delta_gemba || 0) >= 5) || // GEMBA 5점 이상 개선
                    ([gembaImproved, cometImproved, cosImproved].filter(Boolean).length >= 2); // 2개 이상 메트릭 개선
                
                if (significantImprovement) {
                    // 개선된 메트릭들 표시
                    let improvementDetails = [];
                    if (gembaImproved) improvementDetails.push(`GEMBA +${(record.delta_gemba || 0).toFixed(0)}`);
                    if (cometImproved) improvementDetails.push(`COMET +${(record.delta_comet || 0).toFixed(3)}`);
                    if (cosImproved) improvementDetails.push(`COS +${(record.delta_cos || 0).toFixed(3)}`);
                    
                    qualityChangeInfo = `
<div class="quality-change-info" style="margin-bottom: 12px; padding: 8px; background: rgba(59, 130, 246, 0.1); border-radius: 6px; border-left: 3px solid var(--info-color);">
    <div style="font-size: 11px; color: var(--info-color); font-weight: 600;">의미있는 점수 개선 (등급 유지)</div>
    <div style="font-size: 12px; color: var(--text-primary); margin-bottom: 4px;">
        <span class="quality-badge-mini ${originalClass}">${originalLabel}</span>
        <span style="margin: 0 8px; color: var(--info-color);">→</span>
        <span class="quality-badge-mini ${improvedClass}">${improvedLabel}</span>
    </div>
    <div style="font-size: 10px; color: var(--text-muted);">개선: ${improvementDetails.join(', ')}</div>
</div>
                    `;
                } else {
                    // 미미한 개선이거나 개선이 없는 경우는 표시하지 않음
                    qualityChangeInfo = '';
                }
            }
            
            return `
<div class="ape-improvement">
    <div class="ape-header">
        <span class="ape-icon icon icon-improve"></span>
        <span class="ape-title">APE 개선 결과</span>
    </div>
    ${qualityChangeInfo}
    <div class="text-content text-diff">${textDiff}</div>
</div>
            `;
        }

        function generateTextDiff(original, improved) {
            if (!original || !improved || original === improved) {
                return improved || original || 'N/A';
            }

            // 단순한 단어 기반 diff (실제로는 더 정교한 diff 알고리즘 필요)
            const originalWords = original.split(' ');
            const improvedWords = improved.split(' ');
            
            // 간단한 구현: 다른 부분을 하이라이트
            if (originalWords.join(' ') === improvedWords.join(' ')) {
                return improved;
            }

            return `
                <span class="diff-original">${original}</span>
                <span class="diff-improved">${improved}</span>
            `;
        }

        function createEvidenceIndicator(record) {
            const evidence = record.flag?.gemba_reason || '';
            const hasEvidence = evidence && evidence.trim().length > 0;
            
            if (!hasEvidence) return '';
            
            // 이미 우수한 품질의 레코드는 evidence 표시하지 않음
            const isHighQuality = record.tag === 'strict_pass';
            const currentQuality = getQualityClass(record);
            const isExcellentOrVeryGood = currentQuality === 'quality-excellent' || currentQuality === 'quality-very-good';
            
            if (isHighQuality && isExcellentOrVeryGood) {
                return ''; // 우수한 품질이면 evidence 표시 안함
            }
            
            // Evidence 중요도 판단
            const isFailRecord = record.tag === 'fail';
            const isCritical = evidence.toLowerCase().includes('error') || 
                              evidence.toLowerCase().includes('incorrect') ||
                              evidence.toLowerCase().includes('wrong');
            
            let iconClass = 'info';
            if (isFailRecord) iconClass = 'critical';
            else if (isCritical) iconClass = 'critical';
            
            const iconText = iconClass === 'critical' ? '!' : 'i';
            
            return `
<div class="evidence-indicator" data-evidence="${encodeURIComponent(evidence)}" data-type="${iconClass}" onmouseenter="showEvidenceTooltipFromData(this)" onmouseleave="hideEvidenceTooltip(this)">
    <div class="evidence-icon ${iconClass}">${iconText}</div>
    <div class="evidence-tooltip">
        <strong>평가 근거:</strong><br>
        <span class="evidence-text"></span>
    </div>
</div>
            `;
        }

        function showEvidenceTooltipFromData(element) {
            const evidenceEncoded = element.getAttribute('data-evidence');
            const type = element.getAttribute('data-type');
            const evidence = decodeURIComponent(evidenceEncoded);
            
            // 툴팁 내용 업데이트
            const evidenceText = element.querySelector('.evidence-text');
            evidenceText.textContent = evidence;
            
            showEvidenceTooltip(element, evidence, type);
        }

        function showEvidenceTooltip(element, evidence, type) {
            const tooltip = element.querySelector('.evidence-tooltip');
            const icon = element.querySelector('.evidence-icon');
            
            // 먼저 툴팁을 보이게 해서 실제 크기 측정
            tooltip.style.visibility = 'hidden';
            tooltip.style.opacity = '1';
            tooltip.classList.add('show');
            
            // 아이콘의 위치 계산
            const iconRect = icon.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            // 실제 툴팁 크기
            const tooltipWidth = Math.min(tooltipRect.width, 400); // 최대 400px
            const tooltipHeight = tooltipRect.height;
            
            // 화면 크기 계산
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // 기본 위치 (아이콘 위쪽 중앙)
            let left = iconRect.left + iconRect.width / 2 - tooltipWidth / 2;
            let top = iconRect.top - tooltipHeight - 10;
            
            // 화면 경계 조정
            if (left < 10) left = 10;
            if (left + tooltipWidth > viewportWidth - 10) left = viewportWidth - tooltipWidth - 10;
            
            // 위쪽 공간이 부족하면 아래쪽으로 이동
            if (top < 10) {
                top = iconRect.bottom + 10;
                // 아래쪽도 공간이 부족하면 화면 내에 맞추기
                if (top + tooltipHeight > viewportHeight - 10) {
                    top = viewportHeight - tooltipHeight - 10;
                }
            }
            
            // 최종 위치 설정
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.style.width = tooltipWidth + 'px';
            tooltip.style.visibility = 'visible';
        }

        function hideEvidenceTooltip(element) {
            const tooltip = element.querySelector('.evidence-tooltip');
            tooltip.classList.remove('show');
            // 스타일 초기화
            tooltip.style.left = '';
            tooltip.style.top = '';
            tooltip.style.width = '';
            tooltip.style.visibility = '';
        }

        function showScoreInfo(scoreType, currentValue, originalValue, delta) {
            const scoreInfos = {
                'gemba': {
                    name: 'GEMBA Score',
                    description: 'GPT 기반 번역품질 평가 점수',
                    range: '0-100점',
                    interpretation: '85+ 우수, 75+ 양호, 65+ 허용, 45+ 나쁨, 45미만 매우나쁨',
                    usage: '전반적인 번역 품질을 종합 평가. 유창성과 적절성을 모두 고려한 점수입니다.',
                    analysis: '• 85점 이상: 게시/출간 가능한 고품질 번역\n• 75-84점: 경미한 후편집 필요\n• 65-74점: 상당한 후편집 필요\n• 45-64점: 재번역 권장\n• 45점 미만: 심각한 품질 문제',
                    qualityScale: [
                        { range: '85-100', description: '우수 - 게시/출간 가능' },
                        { range: '75-84', description: '양호 - 경미한 편집 필요' },
                        { range: '65-74', description: '허용 - 상당한 편집 필요' },
                        { range: '45-64', description: '나쁨 - 재번역 권장' },
                        { range: '0-44', description: '매우나쁨 - 사용 불가' }
                    ]
                },
                'comet': {
                    name: 'COMET Score', 
                    description: '신경망 기반 번역품질 메트릭',
                    range: '0.0-1.0 (실제 0.2-0.9)',
                    interpretation: '0.80+ 매우우수, 0.75+ 우수, 0.70+ 양호, 0.50+ 나쁨, 0.50미만 매우나쁨',
                    usage: '참조 번역 없이 원문과 번역문만으로 품질을 측정합니다.',
                    analysis: '• 0.80+: 인간 수준의 번역 품질\n• 0.75-0.79: 실용적 사용 가능\n• 0.70-0.74: 이해 가능하나 개선 필요\n• 0.50-0.69: 품질 문제 심각\n• 0.50 미만: 사용 불가 수준',
                    qualityScale: [
                        { range: '0.80-1.0', description: '매우우수 - 인간 수준' },
                        { range: '0.75-0.79', description: '우수 - 실용적 사용' },
                        { range: '0.70-0.74', description: '양호 - 개선 필요' },
                        { range: '0.50-0.69', description: '나쁨 - 품질 문제' },
                        { range: '0.0-0.49', description: '매우나쁨 - 사용 불가' }
                    ]
                },
                'cos': {
                    name: 'Cosine Similarity',
                    description: 'LaBSE 임베딩 기반 의미 유사도',
                    range: '0.0-1.0 (실제 0.5-0.95)',
                    interpretation: '0.85+ 매우우수, 0.75+ 우수, 0.70+ 양호, 0.50+ 나쁨, 0.50미만 매우나쁨',
                    usage: '원문과 번역문의 의미적 유사도를 벡터 공간에서 측정합니다.',
                    analysis: '• 0.85+: 의미 보존 탁월\n• 0.75-0.84: 핵심 의미 보존\n• 0.70-0.74: 일부 의미 손실\n• 0.50-0.69: 의미 왜곡 위험\n• 0.50 미만: 심각한 의미 손실',
                    qualityScale: [
                        { range: '0.85-1.0', description: '매우우수 - 의미 보존 탁월' },
                        { range: '0.75-0.84', description: '우수 - 핵심 의미 보존' },
                        { range: '0.70-0.74', description: '양호 - 일부 의미 손실' },
                        { range: '0.50-0.69', description: '나쁨 - 의미 왜곡 위험' },
                        { range: '0.0-0.49', description: '매우나쁨 - 심각한 의미 손실' }
                    ]
                }
            };

            const info = scoreInfos[scoreType];
            if (!info) return;

            // 모달 타이틀 설정
            document.getElementById('scoreModalTitle').textContent = info.name + ' 상세 정보';
            
            // 헤더 색상을 점수 타입에 따라 동적으로 설정
            const header = document.querySelector('.score-info-header');
            const colorMap = {
                'gemba': 'linear-gradient(135deg, #10b981, #34d399)',
                'comet': 'linear-gradient(135deg, #10b981, #34d399)',
                'cos': 'linear-gradient(135deg, #10b981, #34d399)'    
            };
            header.style.background = colorMap[scoreType] || 'linear-gradient(135deg, #10b981, #34d399)';
            
            // 현재 점수 표시
            document.getElementById('scoreCurrentValue').textContent = 
                scoreType === 'gemba' ? currentValue.toFixed(0) : currentValue.toFixed(3);
            document.getElementById('scoreCurrentLabel').textContent = info.name.toUpperCase();

            // 개선 정보 표시 (APE가 적용된 경우에만)
            const improvementInfo = document.getElementById('scoreImprovementInfo');
            if (delta !== 0 && originalValue !== null) {
                improvementInfo.style.display = 'block';
                
                const deltaElement = document.getElementById('deltaValue');
                deltaElement.textContent = (delta > 0 ? '+' : '') + 
                    (scoreType === 'gemba' ? delta.toFixed(0) : delta.toFixed(3));
                deltaElement.className = `value ${delta > 0 ? 'positive' : 'negative'}`;
                
                document.getElementById('beforeValue').textContent = 
                    scoreType === 'gemba' ? originalValue.toFixed(0) : originalValue.toFixed(3);
                document.getElementById('afterValue').textContent = 
                    scoreType === 'gemba' ? currentValue.toFixed(0) : currentValue.toFixed(3);
            } else {
                improvementInfo.style.display = 'none';
            }

            // 품질 평가 기준 생성
            const qualityScale = document.getElementById('qualityScale');
            qualityScale.innerHTML = info.qualityScale.map(item => `
                <div class="quality-scale-item">
                    <span class="quality-scale-range">${item.range}</span>
                    <span class="quality-scale-description">${item.description}</span>
                </div>
            `).join('');

            // 점수 해석 가이드
            const interpretationColor = {
                'gemba': '#10b981',
                'comet': '#10b981', 
                'cos': '#10b981'
            }[scoreType] || '#10b981';
            
            document.getElementById('scoreInterpretation').innerHTML = `
                <strong style="color: ${interpretationColor};">점수 범위:</strong> ${info.range}<br>
                <strong style="color: ${interpretationColor};">해석 기준:</strong> ${info.interpretation}<br><br>
                <strong style="color: ${interpretationColor};">분석 가이드:</strong><br>
                ${info.analysis.replace(/\n/g, '<br>')}
            `;

            // 평가 방법 설명
            document.getElementById('evaluationMethod').innerHTML = `
                <strong>설명:</strong> ${info.description}<br><br>
                <strong>활용 방법:</strong><br>
                ${info.usage}
            `;

            // 모달 표시
            const modal = document.getElementById('scoreInfoModal');
            modal.classList.add('show');
        }

        function closeScoreInfoModal() {
            const modal = document.getElementById('scoreInfoModal');
            modal.classList.remove('show');
        }

        // 모달 외부 클릭 시 닫기
        document.getElementById('scoreInfoModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeScoreInfoModal();
            }
        });

        function getQualityClass(record) {
            // APE 개선 후의 점수를 사용 (개선이 있다면 개선 후, 없다면 원본)
            const hasApe = record.ape && record.ape !== record.mt && 
                          (record.delta_comet || record.delta_cos || record.delta_gemba);
            
            if (hasApe) {
                // APE 개선 후에는 APE Q-score 사용 (있는 경우)
                const gemba = record.ape_gemba || ((record.gemba || 0) + (record.delta_gemba || 0));
                const comet = (record.comet || 0) + (record.delta_comet || 0);
                const cos = (record.cos || 0) + (record.delta_cos || 0);
                const apeQScore = record.ape_q_score;
                const apeTag = record.ape_tag;
                const gembaReason = record.flag?.gemba_reason; // APE 후에는 보통 no_parse 해결됨
                
                return getQualityClassByScores(gemba, comet, cos, apeQScore, apeTag, gembaReason);
            } else {
                // APE 개선이 없는 경우 원본 Q-score 사용
                const gemba = record.gemba || 0;
                const comet = record.comet || 0;
                const cos = record.cos || 0;
                const qScore = record.q_score;
                const tag = record.tag;
                const gembaReason = record.flag?.gemba_reason;
                
                return getQualityClassByScores(gemba, comet, cos, qScore, tag, gembaReason);
            }
        }

        function getQualityClassByScores(gemba, comet, cos, qScore = null, tag = null, gembaReason = null) {
            // Q-score 기반 품질등급 (2단계 검증: 하한게이트 + Q-밴드)
            
            // 1. 하한 게이트 검사 (절대값 기준)
            const actualGemba = (gembaReason !== "no_parse") ? gemba : 0.0;
            const isNoParse = (gembaReason === "no_parse");
            if (checkFailGate(cos, comet, actualGemba, isNoParse)) {
                return 'quality-poor';  // 하한 게이트 실패 -> 나쁨
            }
            
            // 2. Q-score 값이 있는 경우 사용 (업데이트된 임계값)
            // 하한게이트를 통과했으므로 최소한 "poor" 등급 보장
            if (qScore !== null && qScore !== undefined) {
                if (qScore >= 0.6) {
                    return 'quality-excellent';    // 0.6 이상 -> 매우우수
                } else if (qScore >= 0.25) {
                    return 'quality-very-good';    // 0.25 이상 -> 우수
                } else if (qScore >= -0.1) {
                    return 'quality-good';         // -0.1 이상 -> 양호
                } else if (qScore >= -0.6) {
                    return 'quality-poor';         // -0.6 이상 -> 나쁨
                } else {
                    // 하한게이트 통과했지만 Q-score가 매우 낮은 경우 -> "나쁨"으로 상향
                    return 'quality-poor';         // 매우나쁨 -> 나쁨으로 상향
                }
            }
            
            // 3. Q-score가 없는 경우 기본값 (no_parse 포함)
            console.warn('Q-score 데이터 누락:', { gemba, comet, cos, qScore, tag, gembaReason });
            return 'quality-poor';  // 기본값: 나쁨
        }

        // 하한 게이트 검사 함수
        function checkFailGate(cos, comet, gemba, isNoParse = false) {
            const FAIL_GATE_CONDITIONS = {
                cos: 0.50,
                comet: 0.50,
                gemba: 50
            };
            
            // comet과 cos는 항상 검사
            if (cos < FAIL_GATE_CONDITIONS.cos) return true;
            if (comet < FAIL_GATE_CONDITIONS.comet) return true;
            // gemba는 no_parse가 아닐 때만 검사
            if (!isNoParse && gemba < FAIL_GATE_CONDITIONS.gemba) return true;
            return false;
        }

        function getQualityLabel(record) {
            const qualityClass = getQualityClass(record);
            const labels = {
                'quality-excellent': '매우우수',
                'quality-very-good': '우수',
                'quality-good': '양호',
                'quality-poor': '나쁨',
                'quality-very-poor': '매우나쁨'
            };
            return labels[qualityClass] || '미분류';
        }

        function getQualityLabelByClass(qualityClass) {
            const labels = {
                'quality-excellent': '매우우수',
                'quality-very-good': '우수',
                'quality-good': '양호',
                'quality-poor': '나쁨',
                'quality-very-poor': '매우나쁨'
            };
            return labels[qualityClass] || '미분류';
        }

        function createQualityBadge(record) {
            const hasApe = record.ape && record.ape !== record.mt && 
                          (record.delta_comet || record.delta_cos || record.delta_gemba);
                          
            if (!hasApe) {
                // APE 개선이 없는 경우 - 기존 방식
                const qualityClass = getQualityClass(record);
                const qualityLabel = getQualityLabel(record);
                return `<div class="quality-badge ${qualityClass}">${qualityLabel}</div>`;
            }
            
            // APE 개선이 있는 경우 - 개선 전후 표시
            // 원본 등급 계산 (APE 적용 전)
            const originalGemba = record.gemba || 0;
            const originalComet = record.comet || 0;
            const originalCos = record.cos || 0;
            const originalQScore = record.q_score;
            const originalTag = record.tag;
            const originalGembaReason = record.flag?.gemba_reason;
            
            const originalClass = getQualityClassByScores(originalGemba, originalComet, originalCos, originalQScore, originalTag, originalGembaReason);
            const originalLabel = getQualityLabelByClass(originalClass);
            
            const improvedGemba = record.ape_gemba || ((record.gemba || 0) + (record.delta_gemba || 0));
            const improvedComet = record.comet + (record.delta_comet || 0);
            const improvedCos = record.cos + (record.delta_cos || 0);
            const apeQScore = record.ape_q_score;
            const apeTag = record.ape_tag;
            
            const improvedClass = getQualityClassByScores(improvedGemba, improvedComet, improvedCos, apeQScore, apeTag);
            const improvedLabel = getQualityLabelByClass(improvedClass);
            
            const qualityOrder = {
                'quality-very-poor': 1,
                'quality-poor': 2, 
                'quality-good': 3,
                'quality-very-good': 4,
                'quality-excellent': 5
            };
            
            const isImproved = qualityOrder[improvedClass] > qualityOrder[originalClass];
            
            if (isImproved) {
                return `
                    <div class="quality-badge-improved">
                        <div class="quality-badge ${improvedClass}">${improvedLabel}</div>
                        <div class="quality-improvement-arrow">▲</div>
                        <div class="quality-badge-original ${originalClass}">${originalLabel}</div>
                    </div>
                `;
            } else {
                // 개선되지 않았으면 기존 방식
                return `<div class="quality-badge ${originalClass}">${originalLabel}</div>`;
            }
        }

        function getScorePercentage(scoreType, value) {
            let min, max;
            switch(scoreType) {
                case 'gemba':
                    min = 20; max = 100;
                    break;
                case 'comet':
                    min = 0.2; max = 0.9;
                    break;
                case 'cos':
                    min = 0.5; max = 0.95;
                    break;
                default:
                    return 50;
            }
            
            return Math.min(100, Math.max(0, ((value - min) / (max - min)) * 100));
        }

        function refreshData() {
            resetPagination();
            loadHeaderStats();
            loadRecords();
        }

        function exportData() {
            if (!currentData || currentData.length === 0) {
                alert('내보낼 데이터가 없습니다.');
                return;
            }

            const csv = convertToCSV(currentData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', `mt_quality_analysis_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function convertToCSV(data) {
            const headers = ['Key', 'Source', 'MT', 'APE', 'GEMBA', 'COMET', 'COS', 'Tag', 'Bucket'];
            const rows = data.map(record => [
                record.key || '',
                record.src || '',
                record.mt || '',
                record.ape || '',
                record.gemba || '',
                record.comet || '',
                record.cos || '',
                record.tag || '',
                record.bucket || ''
            ]);

            return [headers, ...rows].map(row => 
                row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')
            ).join('\n');
        }

        // 차트 모달 표시 함수들
        async function showStatsChart(chartType) {
            const modal = document.getElementById('statsModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');
            
            // 모달 타이틀 설정
            const titles = {
                'records': '총 레코드 분석',
                'pass-rate': '품질 통과율 분석',
                'ape-effect': 'APE 개선 효과 분석'
            };
            modalTitle.textContent = titles[chartType] || '통계 분석';
            
            // 로딩 표시
            modalContent.innerHTML = '<div class="loading"><div class="spinner"></div>차트를 생성하는 중...</div>';
            modal.classList.add('show');
            
            try {
                // API에서 분석 데이터 가져오기
                const response = await fetch(`${API_BASE}/analytics`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Analytics data received:', data); // 디버깅용
                
                // 차트 타입별로 다른 내용 생성
                let chartHTML = '';
                switch(chartType) {
                    case 'records':
                        chartHTML = generateRecordsChart(data);
                        break;
                    case 'pass-rate':
                        chartHTML = await generatePassRateChart(data);
                        break;
                    case 'ape-effect':
                        chartHTML = await generateApeEffectChart(data);
                        break;
                    default:
                        chartHTML = '<div class="loading">알 수 없는 차트 타입입니다.</div>';
                }
                
                modalContent.innerHTML = chartHTML;
                
                // 도넛차트 툴팁 이벤트 바인딩 (SVG innerHTML 삽입 후)
                if (chartType === 'pass-rate') {
                    initDonutTooltips(modalContent);
                }
            } catch (error) {
                console.error('차트 데이터 로드 실패:', error);
                modalContent.innerHTML = `
                    <div class="loading">
                        ❌ 차트 데이터 로드에 실패했습니다.<br>
                        <small style="color: var(--text-muted); margin-top: 8px; display: block;">
                            오류: ${error.message}<br>
                            API 서버가 실행 중인지 확인해주세요.
                        </small>
                    </div>`;
            }
        }

        function generateRecordsChart(data) {
            const totalRecords = data.total_records;
            const bucketDistribution = data.distributions.buckets || {};
            
            // 버킷 이름을 더 이해하기 쉽게 변환
            const bucketLabels = {
                'very_short': '매우 짧음',
                'short': '짧음',
                'medium': '보통',
                'long': '긺',
                'very_long': '매우 긺'
            };
            
            const buckets = Object.entries(bucketDistribution).map(([name, count]) => ({
                name: bucketLabels[name] || name,
                originalName: name,
                count: count,
                percentage: (count / totalRecords * 100).toFixed(1)
            }));
            
            // 정렬 (길이 순서대로)
            const bucketOrder = ['very_short', 'short', 'medium', 'long', 'very_long'];
            buckets.sort((a, b) => {
                const aIndex = bucketOrder.indexOf(a.originalName);
                const bIndex = bucketOrder.indexOf(b.originalName);
                return aIndex - bIndex;
            });
            
            // 차트를 위한 최대값 계산 (0이 아닌 최소값 보장)
            const maxCount = Math.max(...buckets.map(b => b.count), 1);
            
            return `
                <div class="chart-grid">
                    <div class="chart-stat">
                        <div class="chart-stat-value">${totalRecords.toLocaleString()}</div>
                        <div class="chart-stat-label">총 레코드 수</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value">${buckets.length}</div>
                        <div class="chart-stat-label">길이 분류</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value">${buckets.reduce((max, bucket) => bucket.count > max.count ? bucket : max, buckets[0])?.name || 'N/A'}</div>
                        <div class="chart-stat-label">최다 분류</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h3 style="margin-bottom: 16px; color: var(--text-primary); text-align: center;">텍스트 길이별 레코드 분포</h3>
                    <div class="simple-chart">
                        ${buckets.map(bucket => {
                            // 완전한 비례 스케일링 - 최소 높이 없음
                            const height = maxCount > 0 ? (bucket.count / maxCount * 100) : 0;
                            // 0인 경우에만 1px로 표시 (완전히 안보이지 않게)
                            const displayHeight = bucket.count === 0 ? 1 : height;
                            const color = getColorByBucket(bucket.originalName);
                            
                            // 디버깅용 로그
                            console.log(`Bucket ${bucket.name}: count=${bucket.count}, maxCount=${maxCount}, height=${height}%, displayHeight=${displayHeight}%`);
                            
                            return `
                                <div class="chart-bar">
                                    <div class="bar" style="height: ${displayHeight}%; background: ${color}">
                                        ${bucket.count > 0 ? `<div class="bar-value">${bucket.count.toLocaleString()}</div>` : ''}
                                    </div>
                                    <div class="bar-label" style="text-align: center;">${bucket.name}<br><span style="font-size: 11px; color: var(--text-muted);">${bucket.percentage}%</span></div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        function getColorByBucket(bucketName) {
            const colors = {
                'very_short': '#ef4444', // Red 500
                'short': '#f97316',      // Orange 500
                'medium': '#3b82f6',     // Blue 500
                'long': '#22c55e',       // Green 500
                'very_long': '#8b5cf6'   // Purple 500
            };
            return colors[bucketName] || '#6b7280'; // Gray 500
        }

        async function generatePassRateChart(data) {
            const total = data.total_records;
            
            // API에서 before/after 품질분포 데이터 가져오기
            const qualityDist = data.quality_distribution || {};
            const beforeDist = qualityDist.before || {};
            const afterDist = qualityDist.after || {};
            
            // Before APE 데이터
            const beforeVeryPoor = beforeDist.very_poor || 0;
            const beforePoor = beforeDist.poor || 0;
            const beforeGood = beforeDist.good || 0;
            const beforeVeryGood = beforeDist.very_good || 0;
            const beforeExcellent = beforeDist.excellent || 0;
            
            // After APE 데이터
            const afterVeryPoor = afterDist.very_poor || 0;
            const afterPoor = afterDist.poor || 0;
            const afterGood = afterDist.good || 0;
            const afterVeryGood = afterDist.very_good || 0;
            const afterExcellent = afterDist.excellent || 0;
            
            // 통계 계산
            const beforePassRate = (((beforeGood + beforeVeryGood + beforeExcellent) / total) * 100).toFixed(1);
            const afterPassRate = (((afterGood + afterVeryGood + afterExcellent) / total) * 100).toFixed(1);
            const beforeExcellentRate = (((beforeVeryGood + beforeExcellent) / total) * 100).toFixed(1);
            const afterExcellentRate = (((afterVeryGood + afterExcellent) / total) * 100).toFixed(1);
            const beforeFailRate = (((beforeVeryPoor + beforePoor) / total) * 100).toFixed(1);
            const afterFailRate = (((afterVeryPoor + afterPoor) / total) * 100).toFixed(1);
            
            // 개선률 계산
            const passRateImprovement = (afterPassRate - beforePassRate).toFixed(1);
            const excellentRateImprovement = (afterExcellentRate - beforeExcellentRate).toFixed(1);
            const failRateReduction = (beforeFailRate - afterFailRate).toFixed(1);
            
            return `
                <div class="chart-grid">
                    <div class="chart-stat">
                        <div class="chart-stat-value">${afterPassRate}%</div>
                        <div class="chart-stat-label">통과율</div>
                        <div class="chart-stat-change" style="color: ${passRateImprovement >= 0 ? '#22c55e' : '#ef4444'};">
                            ${passRateImprovement >= 0 ? '+' : ''}${passRateImprovement}%p
                        </div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value">${afterExcellentRate}%</div>
                        <div class="chart-stat-label">우수등급율</div>
                        <div class="chart-stat-change" style="color: ${excellentRateImprovement >= 0 ? '#22c55e' : '#ef4444'};">
                            ${excellentRateImprovement >= 0 ? '+' : ''}${excellentRateImprovement}%p
                        </div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="color: #ef4444;">${afterFailRate}%</div>
                        <div class="chart-stat-label">품질미달율</div>
                        <div class="chart-stat-change" style="color: ${failRateReduction >= 0 ? '#22c55e' : '#ef4444'};">
                            ${failRateReduction >= 0 ? '-' : '+'}${Math.abs(failRateReduction)}%p
                        </div>
                    </div>
                </div>
                
                <!-- 품질등급 비교 차트 -->
                <div class="quality-comparison-container" style="margin-top: 24px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 32px;">
                        <!-- APE 이전 품질등급표 카드 -->
                        <div class="quality-chart-card" style="background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                            <div class="card-header" style="text-align: center; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border);">
                                <h3 style="margin: 0; color: var(--text-primary); font-size: 18px; font-weight: 600;">수정 이전 품질등급</h3>
                                <p style="margin: 8px 0 0 0; color: var(--text-secondary); font-size: 14px;">총 ${total}건</p>
                            </div>
                            <div class="donut-chart-wrapper" style="display: flex; justify-content: center; position: relative;">
                                <svg class="donut-svg" viewBox="0 0 200 200" style="width: 200px; height: 200px;">
                                    ${generateDonutChartWithTooltip([
                                        { label: '매우우수', value: beforeExcellent, color: '#059669' },
                                        { label: '우수', value: beforeVeryGood, color: '#10b981' },
                                        { label: '양호', value: beforeGood, color: '#f59e0b' },
                                        { label: '나쁨', value: beforePoor, color: '#f97316' },
                                        { label: '매우나쁨', value: beforeVeryPoor, color: '#dc2626' }
                                    ].filter(item => item.value > 0), total, 'before')}
                                </svg>
                                <div id="donut-tooltip-before" class="donut-tooltip" style="position: absolute; background: rgba(0,0,0,0.88); color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; pointer-events: none; opacity: 0; transform: translateY(-8px); transition: all 0.25s ease; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.25); max-width: 250px;"></div>
                            </div>
                        </div>
                        
                        <!-- APE 이후 품질등급표 카드 -->
                        <div class="quality-chart-card" style="background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                            <div class="card-header" style="text-align: center; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border);">
                                <h3 style="margin: 0; color: var(--text-primary); font-size: 18px; font-weight: 600;">수정 이후 품질등급</h3>
                                <p style="margin: 8px 0 0 0; color: var(--text-secondary); font-size: 14px;">총 ${total}건</p>
                            </div>
                            <div class="donut-chart-wrapper" style="display: flex; justify-content: center; position: relative;">
                                <svg class="donut-svg" viewBox="0 0 200 200" style="width: 200px; height: 200px;">
                                    ${generateDonutChartWithTooltip([
                                        { label: '매우우수', value: afterExcellent, color: '#059669' },
                                        { label: '우수', value: afterVeryGood, color: '#10b981' },
                                        { label: '양호', value: afterGood, color: '#f59e0b' },
                                        { label: '나쁨', value: afterPoor, color: '#f97316' },
                                        { label: '매우나쁨', value: afterVeryPoor, color: '#dc2626' }
                                    ].filter(item => item.value > 0), total, 'after', [
                                        { label: '매우우수', beforeValue: beforeExcellent, afterValue: afterExcellent },
                                        { label: '우수', beforeValue: beforeVeryGood, afterValue: afterVeryGood },
                                        { label: '양호', beforeValue: beforeGood, afterValue: afterGood },
                                        { label: '나쁨', beforeValue: beforePoor, afterValue: afterPoor },
                                        { label: '매우나쁨', beforeValue: beforeVeryPoor, afterValue: afterVeryPoor }
                                    ])}
                                </svg>
                                <div id="donut-tooltip-after" class="donut-tooltip" style="position: absolute; background: rgba(0,0,0,0.88); color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; pointer-events: none; opacity: 0; transform: translateY(-8px); transition: all 0.25s ease; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.25); max-width: 250px;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 간소화된 범례 -->
                    <div class="quality-legend-simplified" style="background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin-top: 20px;">
                        <div class="legend-inline" style="display: flex; justify-content: center; align-items: center; gap: 32px; flex-wrap: wrap;">
                            ${[
                                { label: '매우우수', beforeValue: beforeExcellent, afterValue: afterExcellent, color: '#059669' },
                                { label: '우수', beforeValue: beforeVeryGood, afterValue: afterVeryGood, color: '#10b981' },
                                { label: '양호', beforeValue: beforeGood, afterValue: afterGood, color: '#f59e0b' },
                                { label: '나쁨', beforeValue: beforePoor, afterValue: afterPoor, color: '#f97316' },
                                { label: '매우나쁨', beforeValue: beforeVeryPoor, afterValue: afterVeryPoor, color: '#dc2626' }
                            ].map(item => `
                                <div class="legend-item-compact" style="display: flex; align-items: center; gap: 8px;">
                                    <div class="legend-dot" style="width: 14px; height: 14px; border-radius: 50%; background-color: ${item.color}; flex-shrink: 0;"></div>
                                    <span style="color: var(--text-primary); font-weight: 500; font-size: 14px;">${item.label}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <!-- 변화량 요약 -->
                <div class="chart-container" style="margin-top: 24px;">
                    <h3 style="margin-bottom: 16px; color: var(--text-primary); text-align: center; font-size: 16px;">APE 적용 효과 요약</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px;">
                        <div style="text-align: center; padding: 12px; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-size: 18px; font-weight: bold; color: ${passRateImprovement >= 0 ? '#22c55e' : '#ef4444'};">
                                ${passRateImprovement >= 0 ? '+' : ''}${passRateImprovement}%p
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary);">통과율 개선</div>
                        </div>
                        <div style="text-align: center; padding: 12px; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-size: 18px; font-weight: bold; color: ${excellentRateImprovement >= 0 ? '#22c55e' : '#ef4444'};">
                                ${excellentRateImprovement >= 0 ? '+' : ''}${excellentRateImprovement}%p
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary);">우수등급 개선</div>
                        </div>
                        <div style="text-align: center; padding: 12px; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-size: 18px; font-weight: bold; color: ${failRateReduction >= 0 ? '#22c55e' : '#ef4444'};">
                                ${failRateReduction >= 0 ? '-' : '+'}${Math.abs(failRateReduction)}%p
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary);">미달율 감소</div>
                        </div>
                    </div>
                </div>
            `;
        }

        async function generateApeEffectChart(data) {
            const apeData = data.ape_effectiveness || {};
            const tagsData = data.distributions.tags || {};
            
            // APE 데이터 정확하게 추출 - 모든 메트릭
            let avgGembaImprovement = 0;
            let avgCometImprovement = 0;
            let avgCosineImprovement = 0;
            let recordsWithApe = 0;
            
            if (apeData.avg_gemba_improvement !== undefined) {
                avgGembaImprovement = apeData.avg_gemba_improvement;
            }
            if (apeData.avg_comet_improvement !== undefined) {
                avgCometImprovement = (apeData.avg_comet_improvement * 100);
            }
            if (apeData.avg_cosine_improvement !== undefined) {
                avgCosineImprovement = (apeData.avg_cosine_improvement * 100);
            }
            if (apeData.total_ape_records !== undefined) {
                recordsWithApe = apeData.total_ape_records;
            }
            
            const totalRecords = data.total_records;
            const apeUsageRate = totalRecords > 0 ? ((recordsWithApe / totalRecords) * 100) : 0;
            
            // 실제 개선 효과를 퍼센트 기준으로 분류
            let improvementRanges;
            let successfulImprovements = 0;
            
            if (recordsWithApe > 0) {
                // 실제 API에서 개별 레코드의 개선도를 받아와서 분류
                improvementRanges = await calculateRealImprovementDistribution();
                
                // 성공적인 개선 사례 계산 (2% 이상 개선)
                successfulImprovements = improvementRanges.slice(3).reduce((sum, range) => sum + range.count, 0);
            } else {
                improvementRanges = [
                    { 
                        range: '데이터없음', 
                        count: 1, 
                        color: '#6b7280', // Gray 500
                        description: '데이터 없음'
                    }
                ];
            }
            
            // APE 성공률 계산 (2% 이상 개선을 성공으로 간주)
            const successRate = recordsWithApe > 0 ? ((successfulImprovements / recordsWithApe) * 100).toFixed(1) : 0;
            
            // 품질등급 상승률 계산 (API에서 가져오기)
            const meaningfulImprovementRate = apeData.meaningful_improvement_rate ? apeData.meaningful_improvement_rate.toFixed(1) : 0;
            
            return `
                <div class="chart-grid">
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">+${avgGembaImprovement.toFixed(1)}</div>
                        <div class="chart-stat-label">GEMBA<br>개선도</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">${avgCometImprovement > 0 ? '+' : ''}${avgCometImprovement.toFixed(1)}%</div>
                        <div class="chart-stat-label">COMET<br>개선도</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">${avgCosineImprovement > 0 ? '+' : ''}${avgCosineImprovement.toFixed(1)}%</div>
                        <div class="chart-stat-label">COSINE<br>개선도</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">${recordsWithApe.toLocaleString()}</div>
                        <div class="chart-stat-label">편집 적용<br>문장</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">${meaningfulImprovementRate}%</div>
                        <div class="chart-stat-label">품질등급<br>상승률</div>
                    </div>
                </div>
                
                <!-- 메트릭별 개선도 비교 차트 -->
                <div class="chart-container" style="margin-bottom: 24px;">
                    <h3 style="margin-bottom: 16px; color: var(--text-primary); text-align: center;">메트릭별 평균 개선도 비교</h3>
                    <div class="metrics-comparison-chart">
                        ${generateMetricsComparisonChart(avgGembaImprovement, avgCometImprovement, avgCosineImprovement)}
                    </div>
                </div>
            `;
        }

        // 실제 APE 개선도 분포를 계산하는 함수
        async function calculateRealImprovementDistribution() {
            try {
                // APE가 적용된 레코드만 가져오기
                const response = await fetch(`${API_BASE}/records?has_ape=true&limit=10000`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const recordsData = await response.json();
                
                // APE가 적용된 레코드들
                const apeRecords = recordsData.records;
                
                console.log(`APE 레코드 수: ${apeRecords.length}`); // 디버깅용
                
                // 개선도 분류 카운터 초기화
                const improvementCounts = {
                    deterioration: 0,    // <0%
                    noChange: 0,         // 0%
                    minimal: 0,          // 0-2%
                    small: 0,            // 2-5%
                    medium: 0,           // 5-10%
                    large: 0             // ≥10%
                };
                
                // 각 레코드의 개선도 계산 및 분류
                apeRecords.forEach(record => {
                    // COMET 점수 기준으로 개선도 계산 (가장 신뢰할 만한 메트릭)
                    const originalComet = record.comet || 0;
                    const deltaComet = record.delta_comet || 0;
                    
                    if (originalComet > 0) {
                        const improvementPercent = (deltaComet / originalComet) * 100;
                        
                        console.log(`Record ${record.key}: ${improvementPercent.toFixed(2)}%`); // 디버깅용
                        
                        if (improvementPercent < 0) {
                            improvementCounts.deterioration++;
                        } else if (improvementPercent === 0) {
                            improvementCounts.noChange++;
                        } else if (improvementPercent <= 2) {
                            improvementCounts.minimal++;
                        } else if (improvementPercent <= 5) {
                            improvementCounts.small++;
                        } else if (improvementPercent <= 10) {
                            improvementCounts.medium++;
                        } else {
                            improvementCounts.large++;
                        }
                    } else {
                        // 원본 점수가 0인 경우 변화없음으로 분류
                        improvementCounts.noChange++;
                    }
                });
                
                console.log('개선도 분포:', improvementCounts); // 디버깅용
                
                return [
                    { 
                        range: '악화 (<0%)', 
                        count: improvementCounts.deterioration,
                        color: '#dc2626', // Red 600
                        description: '번역 품질이 오히려 악화'
                    },
                    { 
                        range: '변화없음 (0%)', 
                        count: improvementCounts.noChange,
                        color: '#6b7280', // Gray 500
                        description: '개선 효과 없음'
                    },
                    { 
                        range: '미미 (0-2%)', 
                        count: improvementCounts.minimal,
                        color: '#f59e0b', // Amber 500
                        description: '매우 작은 개선'
                    },
                    { 
                        range: '소폭 (2-5%)', 
                        count: improvementCounts.small,
                        color: '#3b82f6', // Blue 500
                        description: '눈에 띄는 개선'
                    },
                    { 
                        range: '중간 (5-10%)', 
                        count: improvementCounts.medium,
                        color: '#10b981', // Emerald 500
                        description: '상당한 품질 향상'
                    },
                    { 
                        range: '큰개선 (≥10%)', 
                        count: improvementCounts.large,
                        color: '#059669', // Emerald 600
                        description: '매우 큰 품질 향상'
                    }
                ];
                
            } catch (error) {
                console.error('실제 개선도 분포 계산 실패:', error);
                // 오류 시 기본값 반환
                return [
                    { 
                        range: '데이터 로드 실패', 
                        count: 1, 
                        color: '#6b7280',
                        description: '데이터를 불러올 수 없음'
                    }
                ];
            }
        }

        // 메트릭별 개선도 비교 차트 생성 - 라인 그래프 방식
        function generateMetricsComparisonChart(gembaImprovement, cometImprovement, cosineImprovement) {
            const metrics = [
                { name: 'GEMBA', value: gembaImprovement, unit: '점', color: '#3b82f6', description: 'GPT 기반 품질 평가' },
                { name: 'COMET', value: cometImprovement, unit: '%', color: '#10b981', description: '신경망 기반 메트릭' },
                { name: 'Cosine', value: cosineImprovement, unit: '%', color: '#8b5cf6', description: '의미 유사도' }
            ];
            
            return `
                <!-- 메트릭 카드 방식 표시 -->
                <div class="metrics-cards" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 28px; margin-bottom: 30px; padding: 0 16px;">
                    ${metrics.map(metric => {
                        const isPositive = metric.value >= 0;
                        const displayValue = metric.name === 'GEMBA' ? 
                            metric.value.toFixed(1) : 
                            metric.value.toFixed(3); // 정확한 값 표시
                        
                        return `
                            <div class="metric-card" style="
                                min-height: 320px;
                                background: linear-gradient(135deg, ${metric.color}15, ${metric.color}05);
                                border: 2px solid ${metric.color}30;
                                border-radius: 20px;
                                padding: 32px 24px;
                                text-align: center;
                                position: relative;
                                overflow: hidden;
                                transition: all 0.3s ease;
                                cursor: pointer;
                                display: flex;
                                flex-direction: column;
                                justify-content: space-between;
                            " onmouseover="this.style.transform='translateY(-5px)'" onmouseout="this.style.transform='translateY(0)'">
                                <!-- 배경 패턴 -->
                                <div style="
                                    position: absolute;
                                    top: -50%;
                                    right: -50%;
                                    width: 100%;
                                    height: 100%;
                                    background: radial-gradient(circle, ${metric.color}20 0%, transparent 70%);
                                    opacity: 0.5;
                                "></div>
                                
                                <!-- 상단 섹션: 아이콘과 이름 -->
                                <div style="flex: 0 0 auto; z-index: 1; position: relative;">
                                    <!-- 메트릭 아이콘 -->
                                    <div style="
                                        width: 60px;
                                        height: 60px;
                                        background: ${metric.color};
                                        border-radius: 50%;
                                        margin: 0 auto 20px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        font-size: 24px;
                                        font-weight: bold;
                                        color: white;
                                        box-shadow: 0 6px 20px ${metric.color}40;
                                    ">
                                        ${metric.name.charAt(0)}
                                    </div>
                                    
                                    <!-- 메트릭 이름 -->
                                    <h3 style="
                                        margin: 0 0 15px 0;
                                        color: var(--text-primary);
                                        font-size: 20px;
                                        font-weight: 700;
                                    ">${metric.name}</h3>
                                </div>
                                
                                <!-- 중단 섹션: 개선값과 설명 -->
                                <div style="flex: 1 1 auto; display: flex; flex-direction: column; justify-content: center; z-index: 1; position: relative;">
                                    <!-- 개선값 -->
                                    <div style="
                                        font-size: 28px;
                                        font-weight: 800;
                                        color: ${isPositive ? '#10b981' : '#ef4444'};
                                        margin-bottom: 8px;
                                    ">
                                        ${isPositive ? '+' : ''}${displayValue}${metric.unit}
                                    </div>
                                    
                                    <!-- 설명 -->
                                    <div style="
                                        font-size: 12px;
                                        color: var(--text-muted);
                                        margin-bottom: 15px;
                                    ">${metric.description}</div>
                                </div>
                                
                                <!-- 하단 섹션: 트렌드 라인 -->
                                <div style="flex: 0 0 auto; height: 40px; position: relative; z-index: 1;">
                                    <svg width="100%" height="100%" style="overflow: visible;">
                                        <defs>
                                            <linearGradient id="gradient-${metric.name}" x1="0%" y1="0%" x2="100%" y2="0%">
                                                <stop offset="0%" style="stop-color:${metric.color}00;stop-opacity:0" />
                                                <stop offset="50%" style="stop-color:${metric.color};stop-opacity:0.3" />
                                                <stop offset="100%" style="stop-color:${metric.color};stop-opacity:0.8" />
                                            </linearGradient>
                                        </defs>
                                        
                                        <!-- 기준선 (0) -->
                                        <line x1="0" y1="20" x2="100%" y2="20" stroke="#ddd" stroke-width="1" stroke-dasharray="2,2"/>
                                        
                                        <!-- 개선 트렌드 라인 -->
                                        <path d="M 0 20 Q 25 ${isPositive ? 10 : 30} 50 ${isPositive ? 5 : 35} T 100 ${isPositive ? 8 : 32}" 
                                              stroke="${metric.color}" 
                                              stroke-width="3" 
                                              fill="none"
                                              style="animation: drawTrend 2s ease-out ${metrics.indexOf(metric) * 0.3}s both;"/>
                                        
                                        <!-- 포인트 -->
                                        <circle cx="100%" cy="${isPositive ? 8 : 32}" r="4" fill="${metric.color}" 
                                               style="animation: showPoint 0.5s ease-out ${2 + metrics.indexOf(metric) * 0.3}s both;"/>
                                    </svg>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <!-- 종합 개선도 그래프 -->
                <div style="background: rgba(59, 130, 246, 0.05); border-radius: 16px; padding: 25px; margin-top: 20px;">
                    <h3 style="text-align: center; margin-bottom: 20px; color: var(--text-primary);">전체 개선 트렌드</h3>
                    <div style="height: 120px; position: relative;">
                        <svg width="100%" height="100%" style="overflow: visible;">
                            <defs>
                                <linearGradient id="areaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:#10b981;stop-opacity:0.3" />
                                    <stop offset="100%" style="stop-color:#10b981;stop-opacity:0.05" />
                                </linearGradient>
                            </defs>
                            
                            <!-- 그리드 라인 -->
                            <g stroke="#e5e7eb" stroke-width="1" opacity="0.5">
                                <line x1="0" y1="30" x2="100%" y2="30"/>
                                <line x1="0" y1="60" x2="100%" y2="60"/>
                                <line x1="0" y1="90" x2="100%" y2="90"/>
                            </g>
                            
                            <!-- 라벨 -->
                            <text x="10" y="25" font-size="10" fill="var(--text-muted)">높음</text>
                            <text x="10" y="65" font-size="10" fill="var(--text-muted)">보통</text>
                            <text x="10" y="95" fill="var(--text-muted)" font-size="10">낮음</text>
                            
                            <!-- GEMBA 라인 -->
                            <path d="M 80 ${90 - Math.abs(gembaImprovement) * 2} L 200 ${88 - Math.abs(gembaImprovement) * 2} L 320 ${85 - Math.abs(gembaImprovement) * 2}" 
                                  stroke="#3b82f6" stroke-width="3" fill="none"
                                  style="animation: drawLine 2s ease-out 0.5s both;"/>
                            
                            <!-- COMET 라인 -->
                            <path d="M 80 ${90 - Math.abs(cometImprovement) * 800} L 200 ${88 - Math.abs(cometImprovement) * 800} L 320 ${85 - Math.abs(cometImprovement) * 800}" 
                                  stroke="#10b981" stroke-width="3" fill="none"
                                  style="animation: drawLine 2s ease-out 1s both;"/>
                            
                            <!-- Cosine 라인 -->
                            <path d="M 80 ${90 - Math.abs(cosineImprovement) * 800} L 200 ${88 - Math.abs(cosineImprovement) * 800} L 320 ${85 - Math.abs(cosineImprovement) * 800}" 
                                  stroke="#8b5cf6" stroke-width="3" fill="none"
                                  style="animation: drawLine 2s ease-out 1.5s both;"/>
                            
                            <!-- 범례 -->
                            <g transform="translate(350, 30)">
                                <circle cx="5" cy="5" r="3" fill="#3b82f6"/>
                                <text x="15" y="9" font-size="11" fill="var(--text-primary)">GEMBA</text>
                                
                                <circle cx="5" cy="25" r="3" fill="#10b981"/>
                                <text x="15" y="29" font-size="11" fill="var(--text-primary)">COMET</text>
                                
                                <circle cx="5" cy="45" r="3" fill="#8b5cf6"/>
                                <text x="15" y="49" font-size="11" fill="var(--text-primary)">Cosine</text>
                            </g>
                        </svg>
                    </div>
                </div>
                
                <style>
                @keyframes drawTrend {
                    from { stroke-dasharray: 200; stroke-dashoffset: 200; }
                    to { stroke-dasharray: 200; stroke-dashoffset: 0; }
                }
                
                @keyframes showPoint {
                    from { opacity: 0; transform: scale(0); }
                    to { opacity: 1; transform: scale(1); }
                }
                
                @keyframes drawLine {
                    from { stroke-dasharray: 300; stroke-dashoffset: 300; }
                    to { stroke-dasharray: 300; stroke-dashoffset: 0; }
                }
                
                .metric-card:hover {
                    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
                }
                
                /* 반응형 미디어 쿼리 */
                @media (max-width: 1024px) {
                    .metrics-cards {
                        grid-template-columns: repeat(2, 1fr) !important;
                        gap: 20px !important;
                    }
                }
                
                @media (max-width: 768px) {
                    .metrics-cards {
                        grid-template-columns: 1fr !important;
                        gap: 16px !important;
                        padding: 0 8px !important;
                    }
                }
                </style>
            `;
        }

        // 개선 임팩트 시각화 생성
        function generateImpactVisualization(metrics) {
            const radius = 35;
            const strokeWidth = 10;
            const center = 50;
            const circumference = 2 * Math.PI * radius;
            
            // 각 메트릭의 임팩트 점수 계산 (시각적 효과를 위해서만 조정)
            const impactScores = metrics.map(metric => {
                const baseScore = Math.abs(metric.value);
                const adjustedScore = metric.name === 'GEMBA' ? baseScore : baseScore * 30; // COMET, Cosine 30배 시각적 증폭
                return Math.min(adjustedScore, 100); // 최대 100으로 제한
            });
            
            const totalImpact = impactScores.reduce((sum, score) => sum + score, 0);
            let cumulativeOffset = 0;
            
            return metrics.map((metric, index) => {
                const normalizedScore = totalImpact > 0 ? impactScores[index] / totalImpact : 0.33;
                const strokeDasharray = circumference * normalizedScore;
                const strokeDashoffset = -cumulativeOffset;
                
                cumulativeOffset += strokeDasharray;
                
                // 임팩트에 따른 동적 스타일
                const intensity = impactScores[index] / 100;
                const opacity = 0.6 + (intensity * 0.4);
                const glowSize = 2 + (intensity * 4);
                
                return `
                    <circle
                        cx="${center}"
                        cy="${center}"
                        r="${radius}"
                        fill="none"
                        stroke="${metric.color}"
                        stroke-width="${strokeWidth + intensity * 3}"
                        stroke-dasharray="${strokeDasharray} ${circumference}"
                        stroke-dashoffset="${strokeDashoffset}"
                        opacity="${opacity}"
                        filter="url(#glow-${index})"
                        style="animation: drawImpactCircle 3s ease-out ${index * 0.5}s both;"
                    />
                    <defs>
                        <filter id="glow-${index}">
                            <feGaussianBlur stdDeviation="${glowSize}" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                `;
            }).join('') + `
                <!-- 중앙 펄스 효과 -->
                <circle
                    cx="${center}"
                    cy="${center}"
                    r="8"
                    fill="#10b981"
                    opacity="0.8"
                    style="animation: centerPulse 2s ease-in-out infinite;"
                />
                
                <style>
                @keyframes drawImpactCircle {
                    from { 
                        stroke-dasharray: 0 ${circumference}; 
                        opacity: 0;
                    }
                    to { 
                        opacity: ${0.6 + (Math.max(...impactScores) / 100 * 0.4)};
                    }
                }
                
                @keyframes centerPulse {
                    0%, 100% { r: 8; opacity: 0.8; }
                    50% { r: 12; opacity: 0.4; }
                }
                </style>
            `;
        }

        // 개선도 도넛 차트 생성
        function generateImprovementDonut(metrics) {
            const radius = 35;
            const strokeWidth = 8;
            const center = 50;
            const circumference = 2 * Math.PI * radius;
            
            let cumulativeOffset = 0;
            
            return metrics.map((metric, index) => {
                // 각 메트릭의 가중치 (정규화된 절댓값)
                const totalAbsValue = metrics.reduce((sum, m) => sum + Math.abs(m.value), 0);
                const normalizedValue = totalAbsValue > 0 ? Math.abs(metric.value) / totalAbsValue : 0.33;
                const strokeDasharray = circumference * normalizedValue;
                const strokeDashoffset = -cumulativeOffset;
                
                cumulativeOffset += strokeDasharray;
                
                return `
                    <circle
                        cx="${center}"
                        cy="${center}"
                        r="${radius}"
                        fill="none"
                        stroke="${metric.color}"
                        stroke-width="${strokeWidth}"
                        stroke-dasharray="${strokeDasharray} ${circumference}"
                        stroke-dashoffset="${strokeDashoffset}"
                        opacity="0.8"
                        style="animation: drawCircle 2s ease-out ${index * 0.3}s both;"
                    />
                `;
            }).join('') + `
                <style>
                @keyframes drawCircle {
                    from { stroke-dasharray: 0 ${circumference}; }
                }
                </style>
            `;
        }

        function generateDonutChart(data, total) {
            // 빈 데이터 처리
            if (!data || data.length === 0 || total === 0) {
                return `<circle cx="100" cy="100" r="70" fill="none" stroke="#6b7280" stroke-width="3" opacity="0.3"/>
                       <text x="100" y="100" text-anchor="middle" dy=".3em" fill="#6b7280" font-size="12">데이터 없음</text>`;
            }
            
            let cumulativeAngle = 0;
            const radius = 70;
            const innerRadius = 45;
            const centerX = 100;
            const centerY = 100;
            
            return data.filter(item => item.value > 0).map(item => {
                const angle = (item.value / total) * 360;
                const startAngle = cumulativeAngle;
                const endAngle = cumulativeAngle + angle;
                
                const x1 = centerX + radius * Math.cos((startAngle - 90) * Math.PI / 180);
                const y1 = centerY + radius * Math.sin((startAngle - 90) * Math.PI / 180);
                const x2 = centerX + radius * Math.cos((endAngle - 90) * Math.PI / 180);
                const y2 = centerY + radius * Math.sin((endAngle - 90) * Math.PI / 180);
                
                const x3 = centerX + innerRadius * Math.cos((endAngle - 90) * Math.PI / 180);
                const y3 = centerY + innerRadius * Math.sin((endAngle - 90) * Math.PI / 180);
                const x4 = centerX + innerRadius * Math.cos((startAngle - 90) * Math.PI / 180);
                const y4 = centerY + innerRadius * Math.sin((startAngle - 90) * Math.PI / 180);
                
                const largeArcFlag = angle > 180 ? 1 : 0;
                
                const pathData = [
                    `M ${x1} ${y1}`,
                    `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`,
                    `L ${x3} ${y3}`,
                    `A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${x4} ${y4}`,
                    'Z'
                ].join(' ');
                
                cumulativeAngle += angle;
                
                return `<path d="${pathData}" fill="${item.color}" stroke="var(--primary-bg)" stroke-width="2"/>`;
            }).join('');
        }

        // 툴팁 기능이 있는 도넛차트 생성 - 깔끔한 2D 모던 디자인 (간격 있음)
        function generateDonutChartWithTooltip(data, total, chartId, comparisonData = null) {
            // 빈 데이터 처리
            if (!data || data.length === 0 || total === 0) {
                return `
                    <circle cx="100" cy="100" r="65" fill="none" stroke="#e5e7eb" stroke-width="20" opacity="0.3"/>
                    <text x="100" y="100" text-anchor="middle" dy=".3em" fill="var(--text-muted)" 
                          font-size="13" font-weight="500">데이터 없음</text>`;
            }
            
            let cumulativeAngle = 0;
            const radius = 65;
            const strokeWidth = 18; // 조금 더 얇게
            const centerX = 100;
            const centerY = 100;
            const gapAngle = 2; // 세그먼트 간 간격 (도 단위)
            
            const segments = data.filter(item => item.value > 0).map((item, index) => {
                const segmentAngle = (item.value / total) * 360 - gapAngle; // 간격만큼 빼기
                const startAngle = cumulativeAngle + (index > 0 ? gapAngle : 0); // 첫 번째 제외하고 간격 추가
                const endAngle = startAngle + segmentAngle;
                
                // 원호의 시작점과 끝점 계산
                const x1 = centerX + radius * Math.cos((startAngle - 90) * Math.PI / 180);
                const y1 = centerY + radius * Math.sin((startAngle - 90) * Math.PI / 180);
                const x2 = centerX + radius * Math.cos((endAngle - 90) * Math.PI / 180);
                const y2 = centerY + radius * Math.sin((endAngle - 90) * Math.PI / 180);
                
                const largeArcFlag = segmentAngle > 180 ? 1 : 0;
                
                // SVG path로 원호 생성 (stroke 기반)
                const pathData = `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`;
                
                cumulativeAngle = endAngle + gapAngle; // 다음 세그먼트를 위해 간격 추가
                
                // 툴팁 내용 생성
                let tooltipContent = '';
                
                if (comparisonData && chartId === 'after') {
                    // 비교 데이터가 있는 경우 (after 차트에서만)
                    const comparison = comparisonData.find(c => c.label === item.label);
                    if (comparison) {
                        const change = comparison.afterValue - comparison.beforeValue;
                        const changePercent = comparison.beforeValue > 0 ? 
                            ((change / comparison.beforeValue) * 100) : 0;
                        const changeIcon = change > 0 ? '↗' : change < 0 ? '↘' : '➖';
                        const changeColor = change > 0 ? '#22c55e' : change < 0 ? '#ef4444' : '#6b7280';
                        
                        tooltipContent = `<div style="font-weight: 600; margin-bottom: 8px; color: ${item.color}; font-size: 15px;">${item.label}</div><div style="margin-bottom: 6px; font-size: 14px;"><span style="font-weight: 600;">${item.value}건</span> (${(item.value/total*100).toFixed(1)}%)</div><div style="border-top: 1px solid rgba(255,255,255,0.15); margin-top: 10px; padding-top: 10px;"><div style="color: #cbd5e1; font-size: 12px; margin-bottom: 4px;">변화량</div><div style="color: ${changeColor}; font-weight: 600; font-size: 14px;">${changeIcon} ${comparison.beforeValue}건 → ${comparison.afterValue}건</div><div style="color: ${changeColor}; font-size: 12px; margin-top: 2px;">${change >= 0 ? '+' : ''}${change}건 ${changePercent !== 0 ? `(${changePercent > 0 ? '+' : ''}${changePercent.toFixed(1)}%)` : ''}</div></div>`;
                    } else {
                        tooltipContent = `<div style="font-weight: 600; margin-bottom: 8px; color: ${item.color}; font-size: 15px;">${item.label}</div><div style="font-size: 14px;"><span style="font-weight: 600;">${item.value}건</span> (${(item.value/total*100).toFixed(1)}%)</div>`;
                    }
                } else {
                    // 기본 툴팁 (before 차트)
                    tooltipContent = `<div style="font-weight: 600; margin-bottom: 8px; color: ${item.color}; font-size: 15px;">${item.label}</div><div style="font-size: 14px;"><span style="font-weight: 600;">${item.value}건</span> (${(item.value/total*100).toFixed(1)}%)</div>`;
                }
                
                return `
                    <path 
                        d="${pathData}" 
                        fill="none"
                        stroke="${item.color}" 
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                        style="cursor: pointer; transition: all 0.3s ease; opacity: 0.9;"
                        data-tip="${encodeURIComponent(tooltipContent)}"
                        data-chart-id="${chartId}"
                        data-color="${item.color}"
                    />
                `;
            }).join('');
            
            return segments;
        }
        
        // 도넛차트 툴팁 초기화 함수 - 심플한 2D 인터랙션 (간격 적용)
        function initDonutTooltips(rootEl) {
            rootEl.querySelectorAll('.donut-chart-wrapper').forEach(wrapper => {
                const chartId = wrapper.querySelector('path[data-chart-id]')?.dataset.chartId;
                if (!chartId) return;
                
                const tipBox = wrapper.querySelector(`#donut-tooltip-${chartId}`);
                if (!tipBox) return;
                
                wrapper.querySelectorAll('path[data-tip]').forEach(path => {
                    const color = path.dataset.color;
                    
                    path.addEventListener('pointerenter', e => {
                        // 툴팁 내용 설정
                        const tooltipContent = decodeURIComponent(path.dataset.tip);
                        tipBox.innerHTML = tooltipContent;
                        tipBox.style.opacity = '1';
                        tipBox.style.transform = 'translateY(0)';
                        tipBox.style.visibility = 'visible';
                        
                        // 심플한 호버 효과 - 두께만 증가 (간격 고려)
                        path.style.strokeWidth = '22'; // 원래 18에서 22로
                        path.style.opacity = '1';
                        
                        // 다른 세그먼트들 약간 흐리게
                        wrapper.querySelectorAll('path[data-tip]').forEach(otherPath => {
                            if (otherPath !== path) {
                                otherPath.style.opacity = '0.4';
                            }
                        });
                        
                        // 초기 위치 설정
                        updateTooltipPositionNew(e, wrapper, tipBox);
                    });
                    
                    path.addEventListener('pointermove', e => {
                        if (tipBox.style.opacity === '1') {
                            updateTooltipPositionNew(e, wrapper, tipBox);
                        }
                    });
                    
                    path.addEventListener('pointerleave', () => {
                        tipBox.style.opacity = '0';
                        tipBox.style.transform = 'translateY(-8px)';
                        tipBox.style.visibility = 'hidden';
                        
                        // 호버 효과 제거
                        path.style.strokeWidth = '18'; // 원래 크기로
                        path.style.opacity = '0.9';
                        
                        // 모든 세그먼트들 원상복구
                        wrapper.querySelectorAll('path[data-tip]').forEach(otherPath => {
                            otherPath.style.opacity = '0.9';
                        });
                    });
                });
            });
        }
        
        // 새로운 툴팁 위치 업데이트 함수
        function updateTooltipPositionNew(event, wrapper, tipBox) {
            const rect = wrapper.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // 툴팁이 차트 영역을 벗어나지 않도록 조정
            let tooltipX = x + 12;
            let tooltipY = y - 10;
            
            const tooltipRect = tipBox.getBoundingClientRect();
            const wrapperWidth = rect.width;
            const wrapperHeight = rect.height;
            
            // 오른쪽 경계 체크
            if (tooltipX + tooltipRect.width > wrapperWidth) {
                tooltipX = x - tooltipRect.width - 12;
            }
            
            // 위쪽 경계 체크
            if (tooltipY < 0) {
                tooltipY = y + 20;
            }
            
            // 아래쪽 경계 체크
            if (tooltipY + tooltipRect.height > wrapperHeight) {
                tooltipY = wrapperHeight - tooltipRect.height - 10;
            }
            
            tipBox.style.left = `${tooltipX}px`;
            tipBox.style.top = `${tooltipY}px`;
        }

        function closeStatsModal() {
            const modal = document.getElementById('statsModal');
            modal.classList.remove('show');
        }

        // 모달 외부 클릭시 닫기
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('statsModal');
            if (event.target === modal) {
                closeStatsModal();
            }
        });

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
    </script>
</body>
</html>