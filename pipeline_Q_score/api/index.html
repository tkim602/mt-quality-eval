<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>번역품질 검사기 | MT Quality Estimator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #0a0e1a;
            --secondary-bg: #1a1f2e;
            --card-bg: #252d3d;
            --accent-bg: #2a3441;
            --success-color: #00d084;
            --danger-color: #ff6b6b;
            --warning-color: #ffa726;
            --info-color: #42a5f5;
            --neutral-color: #6c757d;
            --text-primary: #ffffff;
            --text-secondary: #b3bcc8;
            --text-muted: #8b949e;
            --border-color: #30374a;
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-medium: rgba(0, 0, 0, 0.25);
            --gradient-success: linear-gradient(135deg, #00d084, #00c477);
            --gradient-danger: linear-gradient(135deg, #ff6b6b, #ff5252);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.6;
            font-size: 14px;
            min-height: 100vh;
        }

        .main-header {
            background: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 24px;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            background: var(--gradient-success);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 14px;
            color: var(--text-muted);
            font-weight: 400;
        }

        .header-stats {
            display: flex;
            gap: 24px;
            align-items: stretch; /* 모든 카드를 같은 높이로 맞춤 */
        }

        .stat-item {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 16px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            width: 160px; /* Q-SCORE 개선도 카드에 맞춰 더 넓게 */
            height: 90px; /* 위아래 글씨를 포함할 수 있도록 높이 증가 */
            flex-shrink: 0; /* 크기 축소 방지 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .stat-item:hover {
            border-color: var(--success-color);
            background: var(--accent-bg);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 208, 132, 0.2);
        }

        .stat-item::before {
            content: '▦';
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--success-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s ease;
        }

        /* Professional Icon Styles */
        .icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            font-size: 14px;
            font-weight: 500;
        }

        .icon-chart::before { content: '■'; color: var(--info-color); }
        .icon-star::before { content: '★'; color: var(--warning-color); }
        .icon-warning::before { content: '⚠'; color: var(--danger-color); }
        .icon-improve::before { content: '▲'; color: var(--success-color); }
        .icon-trend-up::before { content: '▲'; color: var(--success-color); }
        .icon-info::before { 
            content: 'i'; 
            background: var(--info-color); 
            border-radius: 50%; 
            width: 14px; 
            height: 14px; 
            font-size: 10px; 
            font-weight: bold; 
            color: white; 
            text-align: center;
            line-height: 14px;
        }
        .icon-arrow-up::before { content: '▲'; color: var(--text-secondary); }
        .icon-more::before { content: '•••'; color: var(--text-secondary); letter-spacing: 2px; }
        .icon-scale::before { content: '⚖'; color: var(--info-color); }
        .icon-guide::before { content: '≡'; color: var(--info-color); }

        .stat-item:hover::before {
            opacity: 1;
            transform: scale(1);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
        }

        .stat-subtext {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 4px;
            opacity: 0.8;
        }

        .stat-item:hover::before {
            opacity: 1;
            transform: scale(1);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        .sidebar {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            height: fit-content;
        }

        .main-content {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: visible;
            position: relative;
        }

        .nav-section {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .nav-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 4px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .nav-item:hover {
            background: var(--accent-bg);
            color: var(--text-primary);
        }

        .nav-item.active {
            background: var(--success-color);
            color: white;
            font-weight: 500;
        }

        .search-section {
            padding: 20px;
        }

        .search-box {
            position: relative;
            margin-bottom: 16px;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 16px;
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--success-color);
            box-shadow: 0 0 0 3px rgba(0, 208, 132, 0.1);
        }

        input[type="text"]::placeholder {
            color: var(--text-muted);
        }

        .filter-group {
            margin-bottom: 16px;
        }

        .filter-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 12px;
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: var(--success-color);
            color: white;
            border-color: var(--success-color);
        }

        /* 범위 슬라이더 스타일 */
        .range-filter {
            margin-bottom: 16px;
        }

        .range-slider-container {
            position: relative;
            margin: 12px 0;
        }

        .dual-range-slider {
            position: relative;
            height: 6px;
            background: var(--accent-bg);
            border-radius: 3px;
            margin: 20px 0;
        }

        .dual-range-slider input[type="range"] {
            position: absolute;
            width: 100%;
            height: 6px;
            background: transparent;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            pointer-events: none;
        }

        .dual-range-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--success-color);
            cursor: pointer;
            border: 2px solid var(--secondary-bg);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            pointer-events: all;
        }

        .dual-range-slider input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--success-color);
            cursor: pointer;
            border: 2px solid var(--secondary-bg);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            pointer-events: all;
        }

        .range-track {
            position: absolute;
            height: 6px;
            background: var(--success-color);
            border-radius: 3px;
            top: 0;
        }

        .range-values {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 8px;
        }

        .range-current {
            font-size: 12px;
            color: var(--success-color);
            font-weight: 500;
            text-align: center;
            margin-top: 4px;
        }

        .delta-toggle {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .toggle-btn {
            flex: 1;
            padding: 6px 8px;
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .toggle-btn:hover,
        .toggle-btn.active {
            background: var(--success-color);
            color: white;
            border-color: var(--success-color);
        }

        .content-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .content-title-info {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: var(--info-color);
            border-radius: 50%;
            color: white;
            font-size: 10px;
            font-weight: 700;
            cursor: help;
            transition: all 0.2s ease;
        }

        .content-title-info:hover {
            background: var(--success-color);
            transform: scale(1.1);
        }

        .content-title-tooltip {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            font-size: 13px;
            font-weight: 400;
            line-height: 1.5;
            color: var(--text-primary);
            white-space: normal;
            width: 400px;
            max-width: 90vw;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 1000;
        }

        .content-title-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--card-bg);
        }

        .content-title-info:hover .content-title-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* 툴팁 반응형 조정 */
        @media (max-width: 768px) {
            .content-title-tooltip {
                width: 320px;
                max-width: 85vw;
                font-size: 12px;
                padding: 14px;
                left: 0;
                transform: translateX(-20px);
            }
        }

        @media (max-width: 480px) {
            .content-title-tooltip {
                width: 280px;
                max-width: 80vw;
                font-size: 11px;
                padding: 12px;
                left: -50px;
                transform: none;
            }
        }

        .view-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .btn {
            padding: 10px 16px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--accent-bg);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--secondary-bg);
            color: var(--text-primary);
            border-color: var(--success-color);
        }

        .btn.primary {
            background: var(--success-color);
            color: white;
            border-color: var(--success-color);
        }

        .btn.primary:hover {
            background: #00c477;
        }

        /* 주식 스타일 레코드 카드 */
        .record-grid {
            padding: 24px;
        }

        .record-card {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: visible;
            transition: all 0.2s;
        }

        .record-card:hover {
            border-color: var(--success-color);
            box-shadow: 0 4px 12px rgba(0, 208, 132, 0.1);
        }

        .record-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .record-id {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            color: var(--text-muted);
            background: var(--accent-bg);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .quality-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .quality-badge-improved {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .quality-badge-original {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            opacity: 0.7;
            position: relative;
        }

        .quality-badge-original::before {
            content: '기존: ';
            font-size: 9px;
            opacity: 0.8;
        }

        .quality-improvement-arrow {
            color: var(--success-color);
            font-size: 14px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .quality-badge-mini {
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            display: inline-block;
        }

        .quality-badge-mini.quality-excellent {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .quality-badge-mini.quality-very-good {
            background: rgba(132, 204, 22, 0.2);
            color: #84cc16;
            border: 1px solid rgba(132, 204, 22, 0.3);
        }

        .quality-badge-mini.quality-good {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .quality-badge-mini.quality-poor {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .quality-badge-mini.quality-very-poor {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .quality-excellent {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .quality-very-good {
            background: rgba(132, 204, 22, 0.2);
            color: #84cc16;
            border: 1px solid rgba(132, 204, 22, 0.3);
        }

        .quality-good {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .quality-poor {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .quality-very-poor {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        /* 주식 스타일 점수 섹션 */
        .scores-section {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        .score-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
        }

        .score-card:hover {
            border-color: var(--success-color);
            transform: translateY(-2px);
        }

        .score-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--neutral-color);
        }

        .score-card.improvement::before {
            background: var(--gradient-success);
        }

        .score-card.decline::before {
            background: var(--gradient-danger);
        }

        .score-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .score-main {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .score-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .score-change {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            font-weight: 600;
        }

        .score-arrow {
            font-size: 16px;
        }

        .score-positive {
            color: var(--success-color);
        }

        .score-negative {
            color: var(--danger-color);
        }

        .score-neutral {
            color: var(--neutral-color);
        }

        .score-percentage {
            font-size: 12px;
            color: var(--text-muted);
        }

        .score-gauge {
            height: 4px;
            background: var(--accent-bg);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 12px;
        }

        .score-fill {
            height: 100%;
            background: var(--success-color);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* 텍스트 diff 스타일 */
        .text-section {
            padding: 20px;
            border-top: 1px solid var(--border-color);
        }

        .text-row {
            margin-bottom: 16px;
        }

        .text-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .text-content {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-primary);
        }

        .text-diff {
            position: relative;
        }

        .diff-original {
            background: rgba(255, 107, 107, 0.15);
            color: #ff8a80;
            padding: 2px 4px;
            border-radius: 3px;
            text-decoration: line-through;
            margin-right: 4px;
        }

        .diff-improved {
            background: rgba(0, 208, 132, 0.15);
            color: #4ade80;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 500;
        }

        /* APE 개선 표시 */
        .ape-improvement {
            background: var(--card-bg);
            border: 1px solid rgba(0, 208, 132, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-top: 12px;
        }

        .ape-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .ape-icon {
            color: var(--success-color);
            font-size: 16px;
        }

        .ape-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--success-color);
        }

        /* 툴팁 스타일 */
        .tooltip {
            position: absolute;
            background: var(--secondary-bg);
            color: var(--text-primary);
            padding: 16px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            max-width: 320px;
            line-height: 1.4;
        }

        .tooltip.show {
            opacity: 1;
            visibility: visible;
        }

        .tooltip-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--success-color);
        }

        .tooltip-section {
            margin-bottom: 8px;
        }

        .tooltip-label {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tooltip-value {
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        /* Evidence 표시 스타일 */
        .evidence-indicator {
            position: relative;
            display: inline-block;
            margin-left: 8px;
            cursor: pointer;
        }

        .evidence-icon {
            background: var(--warning-color);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .evidence-icon.critical {
            background: var(--danger-color);
        }

        .evidence-icon.info {
            background: var(--info-color);
        }

        .evidence-tooltip {
            position: fixed;
            background: var(--secondary-bg);
            color: var(--text-primary);
            padding: 16px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            min-width: 200px;
            max-width: 400px;
            width: auto;
            word-wrap: break-word;
            white-space: normal;
            line-height: 1.4;
            pointer-events: none;
        }

        .evidence-tooltip.show {
            opacity: 1;
            visibility: visible;
        }

        .score-info-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 12px;
            margin-left: 4px;
            transition: color 0.2s;
        }

        .score-info-btn:hover {
            color: var(--success-color);
        }

        .load-more-section {
            padding: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid var(--border-color);
            background: var(--secondary-bg);
            position: relative;
        }

        .load-more-section .btn.primary {
            position: absolute;
            bottom: 24px;
            right: 24px;
            border-radius: 50px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 100;
            font-size: 14px;
            padding: 12px 20px;
        }

        .scroll-to-top {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            color: var(--text-muted);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 99;
            opacity: 0;
            visibility: hidden;
        }

        .scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .scroll-to-top:hover {
            background: var(--success-color);
            color: white;
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 208, 132, 0.3);
        }

        .record-count-info {
            margin-top: 12px;
            font-size: 13px;
            color: var(--text-muted);
            text-align: center;
            flex: 1;
        }

        .record-count-info span {
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* 스크롤 투 탑 버튼 */
        .scroll-to-top {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            color: var(--text-muted);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 99;
            opacity: 0;
            visibility: hidden;
        }

        .scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .scroll-to-top:hover {
            background: var(--success-color);
            color: white;
            transform: translateX(-50%) translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 208, 132, 0.3);
        }

        /* 통계 차트 모달 */
        .stats-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .stats-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .stats-modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 32px;
            max-width: 800px;
            width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        .stats-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .stats-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stats-modal-close {
            background: transparent;
            border: none;
            font-size: 24px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .stats-modal-close:hover {
            background: var(--accent-bg);
            color: var(--text-primary);
        }

        /* 스코어 정보 모달 */
        .score-info-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .score-info-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .score-info-modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 0;
            max-width: 600px;
            width: 90%;
            max-height: 85%;
            overflow: hidden;
            position: relative;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .score-info-header {
            background: linear-gradient(135deg, var(--success-color), #4ade80);
            color: white;
            padding: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-info-title {
            font-size: 24px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .score-info-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .score-info-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .score-info-body {
            padding: 24px;
            overflow-y: auto;
            max-height: 60vh;
        }

        .score-current-value {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-bottom: 24px;
        }

        .score-current-value .value {
            font-size: 36px;
            font-weight: 700;
            color: var(--success-color);
            margin-bottom: 8px;
        }

        .score-current-value .label {
            font-size: 14px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .score-section {
            margin-bottom: 24px;
        }

        .score-section-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .score-section-content {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .score-improvement-info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(34, 197, 94, 0.1));
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
        }

        .score-improvement-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--info-color);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .score-improvement-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
        }

        .score-improvement-item {
            text-align: center;
        }

        .score-improvement-item .value {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .score-improvement-item .value.positive {
            color: var(--success-color);
        }

        .score-improvement-item .value.negative {
            color: var(--error-color);
        }

        .score-improvement-item .label {
            font-size: 12px;
            color: var(--text-muted);
        }

        .quality-scale {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }

        .quality-scale-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .quality-scale-item:last-child {
            border-bottom: none;
        }

        .quality-scale-range {
            font-weight: 600;
            color: var(--text-primary);
        }

        .quality-scale-description {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .chart-container {
            width: 100%;
            height: 400px;
            margin-bottom: 24px;
            position: relative;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .chart-stat {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            min-height: 100px; 
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .chart-stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--success-color);
            margin-bottom: 8px;
        }

        .chart-stat-label {
            font-size: 14px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.2;
            text-align: center;
        }

        .chart-stat-desc {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 8px;
            line-height: 1.4;
        }


        .simple-chart {
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            height: 320px;
            padding: 24px 20px 40px 20px; 
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            gap: 20px;
            position: relative;
        }

        .chart-bar {
            display: flex;
            flex-direction: column;
            align-self: flex-end;
            align-items: center;
            max-width: 120px; 
            flex: 1;
            position: relative;
        }

        .bar {
            width: 100%;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 8px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.2);
            min-height: 0; 
        }

        .bar:hover {
            opacity: 0.9;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
        }

        .bar-value {
            color: white;
            font-size: 13px;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0,0,0,0.7);
            background: rgba(0,0,0,0.3);
            padding: 4px 8px;
            border-radius: 4px;
            backdrop-filter: blur(2px);
            white-space: nowrap;
        }

        .bar-label {
            font-size: 12px;
            color: var(--text-primary);
            text-align: center;
            font-weight: 500;
            line-height: 1.2;
            position: absolute;
            bottom: -35px; /* 라벨을 바 아래로 위치 */
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
        }

        /* 도넛 차트 스타일 */
        .donut-chart {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 300px;
            position: relative;
        }

        .donut-svg {
            width: 200px;
            height: 200px;
        }

        .donut-legend {
            margin-left: 40px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            margin-right: 12px;
        }

        .legend-label {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .legend-value {
            font-size: 12px;
            color: var(--text-muted);
            margin-left: auto;
        }

        /* 새로운 품질 차트 카드 스타일 */
        .quality-comparison-container {
            margin: 24px 0;
        }

        .quality-chart-card {
            transition: all 0.3s ease;
            border-radius: 12px;
        }

        .quality-chart-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.12) !important;
        }

        .quality-legend-simplified {
            transition: all 0.3s ease;
        }

        .legend-item-compact {
            transition: all 0.25s ease;
            cursor: default;
        }

        .legend-item-compact:hover {
            transform: translateY(-1px);
        }

        .donut-tooltip {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, system-ui, sans-serif;
            white-space: nowrap;
            max-width: 280px;
            line-height: 1.4;
        }

        /* 반응형 디자인 */
        @media (max-width: 1024px) {
            .quality-comparison-container > div:first-child {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            
            .legend-inline {
                gap: 20px !important;
            }
        }

        @media (max-width: 768px) {
            .quality-chart-card {
                padding: 16px;
            }
            
            .quality-legend-simplified {
                padding: 16px;
            }
            
            .legend-inline {
                gap: 16px !important;
                justify-content: center !important;
            }
            
            .legend-item-compact {
                flex-shrink: 0;
            }
            
            .donut-tooltip {
                font-size: 12px !important;
                padding: 10px 12px !important;
                max-width: 220px;
            }
        }

        @media (max-width: 480px) {
            .legend-inline {
                flex-direction: column;
                align-items: center;
                gap: 12px !important;
            }
            
            .legend-item-compact {
                justify-content: center;
            }
        }

        @media (max-width: 768px) {
            .main-header {
                padding: 12px 16px;
            }
            
            .header-content {
                flex-direction: column;
                gap: 16px;
                align-items: center;
            }
            
            .logo-section {
                text-align: center;
            }
            
            .logo {
                font-size: 20px;
            }
            
            .subtitle {
                font-size: 12px;
            }
            
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .scores-section {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
            
            .header-stats {
                gap: 8px;
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
            }
            
            .stat-item {
                width: 90px;
                height: 70px;
                flex-shrink: 0;
                padding: 8px 12px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }
            
            .stat-value {
                font-size: 18px;
            }
            
            .stat-label {
                font-size: 9px;
                line-height: 1.1;
            }
            
            .stat-subtext {
                font-size: 7px;
                line-height: 1.1;
            }

            .stats-modal-content {
                margin: 20px;
                padding: 20px;
                max-width: none;
                width: auto;
            }

            .chart-grid {
                grid-template-columns: repeat(2, 1fr); /* 모바일에서는 2열로 */
                gap: 12px;
            }

            .donut-chart {
                flex-direction: column;
                height: auto;
            }

            .donut-legend {
                margin-left: 0;
                margin-top: 20px;
            }
        }

        /* 매우 작은 화면 (480px 이하) */
        @media (max-width: 480px) {
            .main-header {
                padding: 10px 12px;
            }
            
            .header-content {
                gap: 12px;
            }
            
            .logo {
                font-size: 18px;
            }
            
            .subtitle {
                font-size: 11px;
            }
            
            .header-stats {
                gap: 6px;
            }
            
            .stat-item {
                width: 75px;
                height: 60px;
                padding: 6px 8px;
            }
            
            .stat-value {
                font-size: 16px;
            }
            
            .stat-label {
                font-size: 8px;
                line-height: 1.0;
            }
            
            .stat-subtext {
                font-size: 6px;
                line-height: 1.0;
            }
            
            .chart-grid {
                grid-template-columns: 1fr; /* 매우 작은 화면에서는 1열로 */
                gap: 8px;
            }

            .chart-stat {
                padding: 16px;
                min-height: 80px;
            }

            .chart-stat-value {
                font-size: 20px;
            }

            .chart-stat-label {
                font-size: 12px;
            }
        }

        /* 매우 작은 화면 (320px 이하) */
        @media (max-width: 320px) {
            .main-header {
                padding: 8px 10px;
            }
            
            .header-content {
                gap: 10px;
            }
            
            .logo {
                font-size: 16px;
            }
            
            .subtitle {
                font-size: 10px;
            }
            
            .header-stats {
                gap: 4px;
                overflow-x: auto;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .header-stats::-webkit-scrollbar {
                display: none;
            }
            
            .stat-item {
                width: 65px;
                height: 50px;
                padding: 4px 6px;
                flex-shrink: 0;
            }
            
            .stat-value {
                font-size: 14px;
            }
            
            .stat-label {
                font-size: 7px;
                line-height: 0.9;
            }
            
            .stat-subtext {
                display: none; /* 아주 작은 화면에서는 숨김 */
            }
        }

        /* 원문 개선 제안 모달 */
        .source-improvement-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1002;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .source-improvement-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .source-improvement-modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 0;
            max-width: 700px;
            width: 90%;
            max-height: 85%;
            overflow: hidden;
            position: relative;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            animation: modalSlideIn 0.3s ease-out;
        }

        .source-improvement-header {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .source-improvement-title {
            font-size: 20px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .source-improvement-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .source-improvement-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .source-improvement-body {
            padding: 24px;
            overflow-y: auto;
            max-height: 60vh;
        }

        .improvement-section {
            margin-bottom: 20px;
        }

        .improvement-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .improvement-content {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .original-text {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid var(--danger-color);
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
        }

        .improved-text {
            background: rgba(0, 208, 132, 0.1);
            border-left: 3px solid var(--success-color);
            padding: 12px;
            border-radius: 6px;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--accent-bg);
            border-top: 3px solid var(--success-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* SVG 레이더 차트 스타일 */
        .radar-chart-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--card-bg);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            padding: 24px;
            box-shadow: var(--shadow-medium);
            position: relative;
        }

        .radar-svg {
            width: 400px;
            height: 400px;
            margin: 16px 0;
        }

        .radar-polygon {
            fill: rgba(16, 185, 129, 0.3);
            stroke: rgba(16, 185, 129, 0.8);
            stroke-width: 2;
        }

        .radar-grid {
            fill: none;
            stroke: var(--border-color);
            stroke-width: 1;
            stroke-dasharray: 2,2;
        }

        .radar-axis {
            stroke: var(--text-muted);
            stroke-width: 1;
        }

        .radar-label {
            fill: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: central;
        }

        .radar-point {
            fill: rgba(16, 185, 129, 1);
            stroke: white;
            stroke-width: 2;
        }
    </style>
</head>
<body>
    <header class="main-header">
        <div class="header-content">
            <div class="logo-section">
                <div class="logo" onclick="location.reload()" style="cursor: pointer;">번역품질 검사기</div>
                <div class="subtitle">MT Quality Estimator</div>
            </div>
            <div class="header-stats" id="headerStats">
                <div class="stat-item" onclick="showStatsChart('records')">
                    <div class="stat-label">총 레코드</div>
                    <div class="stat-value" id="totalRecords">-</div>
                    <div class="stat-subtext">클릭하여 차트 보기</div>
                </div>
                <div class="stat-item" onclick="showStatsChart('pass-rate')">
                    <div class="stat-label">통과율</div>
                    <div class="stat-value" id="passRate">-</div>
                    <div class="stat-subtext">클릭하여 차트 보기</div>
                </div>
                <div class="stat-item" onclick="showStatsChart('ape-effect')">
                    <div class="stat-label">개선율</div>
                    <div class="stat-value" id="apeEffectiveness">-</div>
                    <div class="stat-subtext">클릭하여 차트 보기</div>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="dashboard-grid">
            <aside class="sidebar">
                <div class="nav-section">
                    <div class="nav-title">분석 도구</div>
                    <div class="nav-item active" data-view="all">
                        <span class="icon icon-chart"></span> 전체 데이터
                    </div>
                    <div class="nav-item" data-view="high-quality">
                        <span class="icon icon-star"></span> 고품질 번역
                    </div>
                    <div class="nav-item" data-view="failed">
                        <span class="icon icon-warning"></span> 품질 미달
                    </div>
                    <div class="nav-item" data-view="ape-improved">
                        <span class="icon icon-improve"></span> 품질 개선
                    </div>
                </div>

                <div class="search-section">
                    <div class="search-box">
                        <select id="searchType" style="width: 100%; padding: 8px 12px; background: var(--accent-bg); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; margin-bottom: 8px;">
                            <option value="all">전체 필드 검색</option>
                            <option value="key">Key</option>
                            <option value="src">원문</option>
                            <option value="mt">기계번역</option>
                            <option value="ape">수정/개선</option>
                        </select>
                        <input type="text" id="searchInput" placeholder="검색어를 입력하세요...">
                    </div>
                    
                    <!-- 필터 초기화 버튼 -->
                    <div style="margin-bottom: 16px; display: flex; justify-content: flex-end;">
                        <button onclick="resetAllFilters()" style="width: 24px; height: 24px; padding: 0; background: var(--accent-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; transition: all 0.2s;" onmouseover="this.style.background='var(--success-color)'; this.style.color='white';" onmouseout="this.style.background='var(--accent-bg)'; this.style.color='var(--text-secondary)';" title="모든 필터 초기화">
                            ↻
                        </button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">품질 등급</label>
                        <div class="filter-buttons">
                            <button class="filter-btn active" data-filter="all">전체</button>
                            <button class="filter-btn" data-filter="excellent">매우우수</button>
                            <button class="filter-btn" data-filter="very-good">우수</button>
                            <button class="filter-btn" data-filter="good">양호</button>
                            <button class="filter-btn" data-filter="poor">나쁨</button>
                            <button class="filter-btn" data-filter="very-poor">매우나쁨</button>
                        </div>
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">텍스트 길이</label>
                        <div class="filter-buttons">
                            <button class="filter-btn active" data-bucket="all">전체</button>
                            <button class="filter-btn" data-bucket="very_short">매우짧음</button>
                            <button class="filter-btn" data-bucket="short">짧음</button>
                            <button class="filter-btn" data-bucket="medium">보통</button>
                            <button class="filter-btn" data-bucket="long">김</button>
                            <button class="filter-btn" data-bucket="very_long">매우김</button>
                        </div>
                    </div>

                    <div class="range-filter">
                        <label class="filter-label">GEMBA 점수</label>
                        <div class="range-slider-container">
                            <div class="dual-range-slider">
                                <div class="range-track" id="gembaTrack"></div>
                                <input type="range" id="gembaMin" min="0" max="100" value="0" step="1">
                                <input type="range" id="gembaMax" min="0" max="100" value="100" step="1">
                            </div>
                            <div class="range-values">
                                <span>0</span>
                                <span>100</span>
                            </div>
                            <div class="range-current" id="gembaRangeCurrent">전체 범위 (0 ~ 100)</div>
                        </div>
                    </div>

                    <div class="range-filter">
                        <label class="filter-label">COMET 점수</label>
                        <div class="range-slider-container">
                            <div class="dual-range-slider">
                                <div class="range-track" id="cometTrack"></div>
                                <input type="range" id="cometMin" min="0" max="100" value="0" step="1">
                                <input type="range" id="cometMax" min="0" max="100" value="100" step="1">
                            </div>
                            <div class="range-values">
                                <span>0.0</span>
                                <span>1.0</span>
                            </div>
                            <div class="range-current" id="cometRangeCurrent">전체 범위 (0.00 ~ 1.00)</div>
                        </div>
                    </div>

                    <div class="range-filter">
                        <label class="filter-label">COS 점수</label>
                        <div class="range-slider-container">
                            <div class="dual-range-slider">
                                <div class="range-track" id="cosTrack"></div>
                                <input type="range" id="cosMin" min="0" max="100" value="0" step="1">
                                <input type="range" id="cosMax" min="0" max="100" value="100" step="1">
                            </div>
                            <div class="range-values">
                                <span>0.0</span>
                                <span>1.0</span>
                            </div>
                            <div class="range-current" id="cosRangeCurrent">전체 범위 (0.00 ~ 1.00)</div>
                        </div>
                    </div>

                    <div class="range-filter">
                        <label class="filter-label">개선도</label>
                        <div class="delta-toggle">
                            <button class="toggle-btn active" data-delta="comet">COMET 개선</button>
                            <button class="toggle-btn" data-delta="cos">COS 개선</button>
                        </div>
                        <div class="range-slider-container">
                            <div class="dual-range-slider">
                                <div class="range-track" id="deltaTrack"></div>
                                <input type="range" id="deltaMin" min="-50" max="50" value="-50" step="1">
                                <input type="range" id="deltaMax" min="-50" max="50" value="50" step="1">
                            </div>
                            <div class="range-values">
                                <span>-0.5</span>
                                <span>+0.5</span>
                            </div>
                            <div class="range-current" id="deltaRangeCurrent">전체 범위 (-0.50 ~ +0.50)</div>
                        </div>
                    </div>
                </div>
            </aside>

            <main class="main-content">
                <div class="content-header">
                    <div class="content-title" id="contentTitle">전체 현황</div>
                    <div class="view-controls">
                        <button class="btn" onclick="refreshData()">
                            <span>↻</span> 새로고침
                        </button>
                        <button class="btn primary" onclick="exportData()">
                            <span>⬇</span> 데이터 내보내기
                        </button>
                    </div>
                </div>

                <div class="record-grid" id="recordGrid">
                    <div class="loading">
                        <div class="spinner"></div>
                        데이터를 불러오는 중...
                    </div>
                </div>

                <div id="loadMoreSection" class="load-more-section" style="display: none;">
                    <div class="record-count-info">
                        현재 <span id="currentCount">0</span>개 / 전체 <span id="totalCount">0</span>개
                    </div>
                    <button class="btn primary" id="loadMoreBtn" onclick="loadMoreRecords()">
                        <span class="icon icon-more"></span> 더보기
                    </button>
                </div>
            </main>
        </div>
    </div>

    <!-- 스크롤 투 탑 버튼 -->
    <div class="scroll-to-top" id="scrollToTop" onclick="scrollToTop()">
        <span class="icon icon-arrow-up"></span>
    </div>

    <!-- 통계 차트 모달 -->
    <div class="stats-modal" id="statsModal">
        <div class="stats-modal-content">
            <div class="stats-modal-header">
                <div class="stats-modal-title" id="modalTitle">통계 분석</div>
                <button class="stats-modal-close" onclick="closeStatsModal()">×</button>
            </div>
            <div id="modalContent">
                <!-- 차트 내용이 여기에 동적으로 삽입됩니다 -->
            </div>
        </div>
    </div>

    <!-- 스코어 정보 모달 -->
    <div class="score-info-modal" id="scoreInfoModal">
        <div class="score-info-modal-content">
            <div class="score-info-header">
                <div class="score-info-title">
                    <span class="icon icon-chart"></span> <span id="scoreModalTitle">점수 상세 정보</span>
                </div>
                <button class="score-info-close" onclick="closeScoreInfoModal()">×</button>
            </div>
            <div class="score-info-body">
                <!-- 1. 점수 섹션 -->
                <div class="score-current-value">
                    <div class="value" id="scoreCurrentValue">-</div>
                    <div class="label" id="scoreCurrentLabel">점수</div>
                </div>

                <!-- 2. 개선도 섹션 -->
                <div class="score-improvement-info" id="scoreImprovementInfo" style="display: none;">
                    <div class="score-improvement-title">
                        <span class="icon icon-trend-up"></span> 분석 결과
                    </div>
                    <div class="score-improvement-details">
                        <div class="score-improvement-item">
                            <div class="value" id="deltaValue">-</div>
                            <div class="label">개선도</div>
                        </div>
                        <div class="score-improvement-item">
                            <div class="value" id="beforeValue">-</div>
                            <div class="label">개선 전</div>
                        </div>
                        <div class="score-improvement-item">
                            <div class="value" id="afterValue">-</div>
                            <div class="label">개선 후</div>
                        </div>
                    </div>
                </div>

                <!-- 3. 세부정보 섹션 (기존 활용방법) -->
                <div class="score-section">
                    <div class="score-section-title">
                        <span class="icon icon-info"></span> 세부 정보
                    </div>
                    <div class="score-section-content" id="evaluationMethod">
                        <!-- 평가 방법 설명이 여기에 동적으로 추가됩니다 -->
                    </div>
                </div>

                <!-- 4. 품질평가기준 섹션 (테이블 형태) -->
                <div class="score-section">
                    <div class="score-section-title">
                        <span class="icon icon-scale"></span> 품질 평가 기준
                    </div>
                    <div class="score-section-content">
                        <div class="quality-scale" id="qualityScale">
                            <!-- 품질 기준이 여기에 동적으로 추가됩니다 -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 원문 개선 제안 모달 -->
    <div class="source-improvement-modal" id="sourceImprovementModal">
        <div class="source-improvement-modal-content">
            <div class="source-improvement-header">
                <div class="source-improvement-title">
                    <span>🔄</span> 원문 개선 제안
                </div>
                <button class="source-improvement-close" onclick="closeSourceImprovementModal()">×</button>
            </div>
            <div class="source-improvement-body">
                <div class="improvement-section">
                    <div class="improvement-section-title">
                        <span class="icon icon-warning"></span> 현재 원문
                    </div>
                    <div class="improvement-content">
                        <div class="original-text" id="originalSourceText">
                            <!-- 원본 원문이 여기에 표시됩니다 -->
                        </div>
                    </div>
                </div>

                <div class="improvement-section">
                    <div class="improvement-section-title">
                        <span class="icon icon-improve"></span> 개선 제안
                    </div>
                    <div class="improvement-content">
                        <div class="improved-text" id="improvedSourceText">
                            <div class="loading">
                                <div class="spinner"></div>개선안 생성 중...
                            </div>
                        </div>
                    </div>
                </div>

                <div class="improvement-section">
                    <div class="improvement-section-title">
                        <span class="icon icon-info"></span> 개선 근거
                    </div>
                    <div class="improvement-content" id="improvementReason">
                        <div class="loading">
                            <div class="spinner"></div>개선 근거 분석 중...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';
        let currentData = [];
        let allData = []; // 전체 데이터 저장
        let displayLimit = 10; // 현재 표시 개수
        let currentFilters = {
            view: 'all',
            quality: 'all',
            bucket: 'all',
            search: '',
            searchType: 'all',
            ranges: {
                gemba: { min: 0, max: 100, enabled: false },
                comet: { min: 0, max: 1, enabled: false },
                cos: { min: 0, max: 1, enabled: false },
                delta: { min: -0.5, max: 0.5, enabled: false, type: 'comet' }
            }
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            loadHeaderStats();
            loadRecords();
            setupEventListeners();
            setupScrollToTop();
        });

        function setupScrollToTop() {
            const scrollToTopBtn = document.getElementById('scrollToTop');
            
            window.addEventListener('scroll', function() {
                if (window.pageYOffset > 300) {
                    scrollToTopBtn.classList.add('visible');
                } else {
                    scrollToTopBtn.classList.remove('visible');
                }
            });
        }

        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        function setupEventListeners() {
            // 내비게이션 아이템
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                    currentFilters.view = this.dataset.view;
                    updateContentTitle();
                    resetPagination();
                    loadRecords();
                });
            });

            // 필터 버튼들
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const group = this.parentElement;
                    group.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    if (this.dataset.filter) {
                        currentFilters.quality = this.dataset.filter;
                    }
                    if (this.dataset.bucket) {
                        currentFilters.bucket = this.dataset.bucket;
                    }
                    
                    resetPagination();
                    loadRecords();
                });
            });

            // 검색
            document.getElementById('searchInput').addEventListener('input', function() {
                currentFilters.search = this.value;
                currentFilters.searchType = document.getElementById('searchType').value;
                resetPagination();
                debounce(loadRecords, 300)();
            });

            document.getElementById('searchType').addEventListener('change', function() {
                currentFilters.searchType = this.value;
                if (currentFilters.search) {
                    resetPagination();
                    loadRecords();
                }
            });

            // 범위 슬라이더 이벤트
            setupRangeSliders();
        }

        function setupRangeSliders() {
            // GEMBA 듀얼 레인지 슬라이더
            const gembaMin = document.getElementById('gembaMin');
            const gembaMax = document.getElementById('gembaMax');
            const gembaTrack = document.getElementById('gembaTrack');
            
            function updateGembaRange() {
                let minVal = parseInt(gembaMin.value);
                let maxVal = parseInt(gembaMax.value);
                
                if (minVal > maxVal) {
                    [minVal, maxVal] = [maxVal, minVal];
                    gembaMin.value = minVal;
                    gembaMax.value = maxVal;
                }
                
                currentFilters.ranges.gemba.min = minVal;
                currentFilters.ranges.gemba.max = maxVal;
                currentFilters.ranges.gemba.enabled = minVal > 0 || maxVal < 100;
                
                // 트랙 업데이트
                const minPercent = (minVal / 100) * 100;
                const maxPercent = (maxVal / 100) * 100;
                gembaTrack.style.left = minPercent + '%';
                gembaTrack.style.width = (maxPercent - minPercent) + '%';
                
                document.getElementById('gembaRangeCurrent').textContent = 
                    currentFilters.ranges.gemba.enabled ? `범위: ${minVal} ~ ${maxVal}점` : '전체 범위 (0 ~ 100)';
                
                debounce(loadRecordsWithReset, 300)();
            }
            
            gembaMin.addEventListener('input', updateGembaRange);
            gembaMax.addEventListener('input', updateGembaRange);
            updateGembaRange(); // 초기화

            // COMET 듀얼 레인지 슬라이더
            const cometMin = document.getElementById('cometMin');
            const cometMax = document.getElementById('cometMax');
            const cometTrack = document.getElementById('cometTrack');
            
            function updateCometRange() {
                let minVal = parseInt(cometMin.value);
                let maxVal = parseInt(cometMax.value);
                
                if (minVal > maxVal) {
                    [minVal, maxVal] = [maxVal, minVal];
                    cometMin.value = minVal;
                    cometMax.value = maxVal;
                }
                
                const minScore = minVal / 100;
                const maxScore = maxVal / 100;
                
                currentFilters.ranges.comet.min = minScore;
                currentFilters.ranges.comet.max = maxScore;
                currentFilters.ranges.comet.enabled = minVal > 0 || maxVal < 100;
                
                // 트랙 업데이트
                const minPercent = (minVal / 100) * 100;
                const maxPercent = (maxVal / 100) * 100;
                cometTrack.style.left = minPercent + '%';
                cometTrack.style.width = (maxPercent - minPercent) + '%';
                
                document.getElementById('cometRangeCurrent').textContent = 
                    currentFilters.ranges.comet.enabled ? `범위: ${minScore.toFixed(2)} ~ ${maxScore.toFixed(2)}` : '전체 범위 (0.00 ~ 1.00)';
                
                debounce(loadRecordsWithReset, 300)();
            }
            
            cometMin.addEventListener('input', updateCometRange);
            cometMax.addEventListener('input', updateCometRange);
            updateCometRange(); // 초기화

            // COS 듀얼 레인지 슬라이더
            const cosMin = document.getElementById('cosMin');
            const cosMax = document.getElementById('cosMax');
            const cosTrack = document.getElementById('cosTrack');
            
            function updateCosRange() {
                let minVal = parseInt(cosMin.value);
                let maxVal = parseInt(cosMax.value);
                
                if (minVal > maxVal) {
                    [minVal, maxVal] = [maxVal, minVal];
                    cosMin.value = minVal;
                    cosMax.value = maxVal;
                }
                
                const minScore = minVal / 100;
                const maxScore = maxVal / 100;
                
                currentFilters.ranges.cos.min = minScore;
                currentFilters.ranges.cos.max = maxScore;
                currentFilters.ranges.cos.enabled = minVal > 0 || maxVal < 100;
                
                // 트랙 업데이트
                const minPercent = (minVal / 100) * 100;
                const maxPercent = (maxVal / 100) * 100;
                cosTrack.style.left = minPercent + '%';
                cosTrack.style.width = (maxPercent - minPercent) + '%';
                
                document.getElementById('cosRangeCurrent').textContent = 
                    currentFilters.ranges.cos.enabled ? `범위: ${minScore.toFixed(2)} ~ ${maxScore.toFixed(2)}` : '전체 범위 (0.00 ~ 1.00)';
                
                debounce(loadRecordsWithReset, 300)();
            }
            
            cosMin.addEventListener('input', updateCosRange);
            cosMax.addEventListener('input', updateCosRange);
            updateCosRange(); // 초기화

            // Delta 듀얼 레인지 슬라이더
            const deltaMin = document.getElementById('deltaMin');
            const deltaMax = document.getElementById('deltaMax');
            const deltaTrack = document.getElementById('deltaTrack');
            
            function updateDeltaRange() {
                let minVal = parseInt(deltaMin.value);
                let maxVal = parseInt(deltaMax.value);
                
                if (minVal > maxVal) {
                    [minVal, maxVal] = [maxVal, minVal];
                    deltaMin.value = minVal;
                    deltaMax.value = maxVal;
                }
                
                const minScore = minVal / 100;
                const maxScore = maxVal / 100;
                
                currentFilters.ranges.delta.min = minScore;
                currentFilters.ranges.delta.max = maxScore;
                currentFilters.ranges.delta.enabled = minVal > -50 || maxVal < 50;
                
                // 트랙 업데이트 (음수 범위 고려)
                const minPercent = ((minVal + 50) / 100) * 100;
                const maxPercent = ((maxVal + 50) / 100) * 100;
                deltaTrack.style.left = minPercent + '%';
                deltaTrack.style.width = (maxPercent - minPercent) + '%';
                
                document.getElementById('deltaRangeCurrent').textContent = 
                    currentFilters.ranges.delta.enabled ? 
                    `범위: ${minScore >= 0 ? '+' : ''}${minScore.toFixed(2)} ~ ${maxScore >= 0 ? '+' : ''}${maxScore.toFixed(2)}` : 
                    '전체 범위 (-0.50 ~ +0.50)';
                
                debounce(loadRecordsWithReset, 300)();
            }
            
            deltaMin.addEventListener('input', updateDeltaRange);
            deltaMax.addEventListener('input', updateDeltaRange);
            updateDeltaRange(); // 초기화

            // Delta 타입 토글
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentFilters.ranges.delta.type = this.dataset.delta;
                    if (currentFilters.ranges.delta.enabled) {
                        loadRecordsWithReset();
                    }
                });
            });
        }

        function loadRecordsWithReset() {
            resetPagination();
            loadRecords();
        }

        function resetAllFilters() {
            // 페이지 새로고침으로 모든 설정을 완전히 초기화
            location.reload();
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function updateContentTitle() {
            const titles = {
                'all': '전체 데이터',
                'high-quality': '고품질 번역',
                'failed': '품질 미달',
                'ape-improved': '개선 효과'
            };
            
            const descriptions = {
                'high-quality': '매우우수(Excellent) 및 우수(Very Good) 등급의 번역으로, COMET 점수 0.8+ 또는 Q-score 0.25+ 수준입니다. 자연스럽고 정확한 고품질 번역을 의미합니다.',
                'failed': '나쁨(Poor) 및 매우나쁨(Very Poor) 등급의 번역으로, 기본 품질 기준(COMET 0.5+, COS 0.5+, GEMBA 50+)을 충족하지 못한 번역입니다.'
            };
            
            const currentView = currentFilters.view;
            const title = titles[currentView] || '번역품질 분석';
            const description = descriptions[currentView];
            
            const titleElement = document.getElementById('contentTitle');
            
            if (description) {
                titleElement.innerHTML = `
                    ${title}
                    <div class="content-title-info">
                        !
                        <div class="content-title-tooltip">
                            ${description}
                        </div>
                    </div>
                `;
            } else {
                titleElement.textContent = title;
            }
        }

        function resetPagination() {
            displayLimit = 10;
            allData = [];
        }

        async function loadHeaderStats() {
            try {
                const response = await fetch(`${API_BASE}/analytics`);
                const data = await response.json();
                
                document.getElementById('totalRecords').textContent = data.total_records.toLocaleString();
                
                // APE 적용 후 통과율 사용
                const qualityDist = data.quality_distribution || {};
                const afterDist = qualityDist.after || {};
                const total = data.total_records;
                
                // 개선 후 통과율 (양호 이상 = good + very_good + excellent)
                const afterGood = afterDist.good || 0;
                const afterVeryGood = afterDist.very_good || 0; 
                const afterExcellent = afterDist.excellent || 0;
                const afterPassRate = total > 0 ? (((afterGood + afterVeryGood + afterExcellent) / total) * 100) : 0;
                
                document.getElementById('passRate').textContent = afterPassRate.toFixed(1) + '%';
                
                // 품질등급 상승률 사용 (API에서 받은 meaningful_improvement_rate)
                const apeData = data.ape_effectiveness || {};
                const meaningfulImprovementRateNum = Number(apeData.meaningful_improvement_rate) || 0;
                const meaningfulImprovementRate = meaningfulImprovementRateNum.toFixed(1);
                
                document.getElementById('apeEffectiveness').textContent = 
                    (meaningfulImprovementRateNum > 0 ? '+' : '') + meaningfulImprovementRate + '%';
            } catch (error) {
                console.error('헤더 통계 로드 실패:', error);
            }
        }

        async function loadRecords() {
            const grid = document.getElementById('recordGrid');
            grid.innerHTML = '<div class="loading"><div class="spinner"></div>데이터를 불러오는 중...</div>';

            try {
                let url = `${API_BASE}/records?limit=10000`; // 모든 APE 데이터를 가져옴
                
                // 뷰별 필터링 - 개선 후 품질 등급 기준으로 클라이언트에서 필터링
                // API에서는 모든 데이터를 가져오고, 클라이언트에서 개선 후 품질 등급으로 필터링
                switch (currentFilters.view) {
                    case 'ape-improved':
                        url += '&has_ape=true';
                        break;
                    // high-quality와 failed는 클라이언트에서 개선 후 품질 등급으로 필터링
                }

                // 추가 필터링
                if (currentFilters.bucket !== 'all') {
                    url += `&bucket=${currentFilters.bucket}`;
                }

                const response = await fetch(url);
                const data = await response.json();
                allData = data.records; // 전체 데이터 저장

                // 품질 등급 필터 적용
                if (currentFilters.quality !== 'all') {
                    allData = allData.filter(record => {
                        // APE 개선이 있는 경우 개선 후 품질로 필터링
                        const hasApe = record.ape && record.ape !== record.mt && 
                                      (record.delta_comet || record.delta_cos);
                        
                        let qualityClass;
                        if (hasApe) {
                            // 개선 후 점수로 품질 계산 (APE Q-score 우선 사용)
                            const improvedGemba = record.gemba + (record.delta_gemba || 0);
                            const improvedComet = record.comet + (record.delta_comet || 0);
                            const improvedCos = record.cos + (record.delta_cos || 0);
                            const apeQScore = record.ape_q_score;
                            const apeTag = record.ape_tag;
                            qualityClass = getQualityClassByScores(improvedGemba, improvedComet, improvedCos, apeQScore, apeTag);
                        } else {
                            // 개선이 없는 경우 원래 품질
                            qualityClass = getQualityClass(record);
                        }
                        
                        const qualityMap = {
                            'excellent': 'quality-excellent',
                            'very-good': 'quality-very-good', 
                            'good': 'quality-good',
                            'poor': 'quality-poor',
                            'very-poor': 'quality-very-poor'
                        };
                        return qualityClass === qualityMap[currentFilters.quality];
                    });
                }

                // 뷰별 필터링 - 개선 후 품질 등급 기준
                if (currentFilters.view === 'high-quality' || currentFilters.view === 'failed') {
                    allData = allData.filter(record => {
                        // APE 개선이 있는 경우 개선 후 품질로 필터링
                        const hasApe = record.ape && record.ape !== record.mt && 
                                      (record.delta_comet || record.delta_cos);
                        
                        let qualityClass;
                        if (hasApe) {
                            // 개선 후 점수로 품질 계산 (APE Q-score 우선 사용)
                            const improvedGemba = record.gemba + (record.delta_gemba || 0);
                            const improvedComet = record.comet + (record.delta_comet || 0);
                            const improvedCos = record.cos + (record.delta_cos || 0);
                            const apeQScore = record.ape_q_score;
                            const apeTag = record.ape_tag;
                            qualityClass = getQualityClassByScores(improvedGemba, improvedComet, improvedCos, apeQScore, apeTag);
                        } else {
                            // 개선이 없는 경우 원래 품질
                            qualityClass = getQualityClass(record);
                        }
                        
                        if (currentFilters.view === 'high-quality') {
                            // 고품질: 매우우수 + 우수 등급만
                            return qualityClass === 'quality-excellent' || qualityClass === 'quality-very-good';
                        } else if (currentFilters.view === 'failed') {
                            // 품질미달: 나쁨 + 매우나쁨 등급만 (양호 제외!)
                            return qualityClass === 'quality-poor' || qualityClass === 'quality-very-poor';
                        }
                        return true;
                    });
                }

                // 검색 필터 적용
                if (currentFilters.search) {
                    allData = allData.filter(record => {
                        const searchTerm = currentFilters.search.toLowerCase();
                        const searchType = currentFilters.searchType || 'all';
                        
                        switch(searchType) {
                            case 'key':
                                return (record.key || '').toLowerCase().includes(searchTerm);
                            case 'src':
                                return (record.src || '').toLowerCase().includes(searchTerm);
                            case 'mt':
                                return (record.mt || '').toLowerCase().includes(searchTerm);
                            case 'ape':
                                return (record.ape || '').toLowerCase().includes(searchTerm);
                            case 'all':
                            default:
                                return (record.key || '').toLowerCase().includes(searchTerm) ||
                                       (record.src || '').toLowerCase().includes(searchTerm) ||
                                       (record.mt || '').toLowerCase().includes(searchTerm) ||
                                       (record.ape || '').toLowerCase().includes(searchTerm);
                        }
                    });
                }

                // 범위 필터 적용
                allData = allData.filter(record => {
                    // GEMBA 범위 필터
                    if (currentFilters.ranges.gemba.enabled) {
                        const gembaScore = record.gemba + (record.delta_gemba || 0);
                        if (gembaScore < currentFilters.ranges.gemba.min || 
                            gembaScore > currentFilters.ranges.gemba.max) {
                            return false;
                        }
                    }

                    // COMET 범위 필터
                    if (currentFilters.ranges.comet.enabled) {
                        const cometScore = record.comet + (record.delta_comet || 0);
                        if (cometScore < currentFilters.ranges.comet.min || 
                            cometScore > currentFilters.ranges.comet.max) {
                            return false;
                        }
                    }

                    // COS 범위 필터
                    if (currentFilters.ranges.cos.enabled) {
                        const cosScore = record.cos + (record.delta_cos || 0);
                        if (cosScore < currentFilters.ranges.cos.min || 
                            cosScore > currentFilters.ranges.cos.max) {
                            return false;
                        }
                    }

                    // Delta 범위 필터
                    if (currentFilters.ranges.delta.enabled) {
                        const deltaType = currentFilters.ranges.delta.type;
                        const deltaValue = deltaType === 'comet' ? 
                            (record.delta_comet || 0) : (record.delta_cos || 0);
                        if (deltaValue < currentFilters.ranges.delta.min || 
                            deltaValue > currentFilters.ranges.delta.max) {
                            return false;
                        }
                    }

                    return true;
                });

                // 현재 표시할 데이터 설정
                currentData = allData.slice(0, displayLimit);
                renderRecords(currentData);
                updateLoadMoreSection();
            } catch (error) {
                console.error('데이터 로드 실패:', error);
                grid.innerHTML = '<div class="loading">데이터 로드에 실패했습니다.</div>';
            }
        }

        function loadMoreRecords() {
            const newLimit = displayLimit + 20;
            currentData = allData.slice(0, newLimit);
            displayLimit = newLimit;
            
            // 기존 레코드 유지하고 새 레코드만 추가
            const grid = document.getElementById('recordGrid');
            const newRecords = allData.slice(displayLimit - 20, displayLimit);
            const newHtml = newRecords.map(record => createRecordCard(record)).join('');
            grid.innerHTML += newHtml;
            
            updateLoadMoreSection();
        }

        function updateLoadMoreSection() {
            const loadMoreSection = document.getElementById('loadMoreSection');
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            const currentCount = document.getElementById('currentCount');
            const totalCount = document.getElementById('totalCount');
            
            const hasMore = displayLimit < allData.length;
            
            if (allData.length > 0) {
                loadMoreSection.style.display = 'block';
                currentCount.textContent = Math.min(displayLimit, allData.length).toLocaleString();
                totalCount.textContent = allData.length.toLocaleString();
                
                if (hasMore) {
                    loadMoreBtn.style.display = 'block';
                    const remaining = allData.length - displayLimit;
                    const nextLoad = Math.min(20, remaining);
                    loadMoreBtn.innerHTML = `<span class="icon icon-more"></span> 더보기`;
                } else {
                    loadMoreBtn.style.display = 'none';
                }
            } else {
                loadMoreSection.style.display = 'none';
            }
        }

        function renderRecords(records) {
            const grid = document.getElementById('recordGrid');
            
            if (!records || records.length === 0) {
                grid.innerHTML = '<div class="loading"><span class="icon icon-warning"></span> 표시할 데이터가 없습니다.</div>';
                return;
            }

            const html = records.map(record => createRecordCard(record)).join('');
            grid.innerHTML = html;
        }

        function createRecordCard(record) {
            const hasApe = record.ape && record.ape !== record.mt;

            return `
<div class="record-card">
    <div class="record-header">
        <div class="record-id">${record.key || 'N/A'}</div>
        ${createQualityBadge(record)}
    </div>
    
    <div class="scores-section">
        ${createScoreCard('GEMBA', record.gemba, record.gemba + (record.delta_gemba || 0), 'gemba')}
        ${createScoreCard('COMET', record.comet, record.comet + (record.delta_comet || 0), 'comet')}
        ${createScoreCard('COS', record.cos, record.cos + (record.delta_cos || 0), 'cos')}
    </div>
    
    <div class="text-section">
        <div class="text-row">
            <div class="text-label">원문</div>
            <div class="text-content">${record.src || 'N/A'}</div>
        </div>
        
        <div class="text-row">
            <div class="text-label">기계번역</div>
            <div class="text-content">
                ${record.mt || 'N/A'}
                ${createEvidenceIndicator(record)}
            </div>
        </div>
        
        ${hasApe ? createApeImprovement(record) : ''}
    </div>
</div>
            `;
        }

        function createScoreCard(label, originalScore, improvedScore, type) {
            if (!originalScore && originalScore !== 0) {
                return `
                    <div class="score-card">
                        <div class="score-label">${label}</div>
                        <div class="score-value">N/A</div>
                    </div>
                `;
            }

            const hasImprovement = improvedScore && improvedScore !== originalScore;
            const delta = hasImprovement ? improvedScore - originalScore : 0;
            const deltaPercent = originalScore ? (delta / originalScore * 100) : 0;
            const cardClass = delta > 0 ? 'improvement' : delta < 0 ? 'decline' : '';

            let displayValue = originalScore;
            let changeDisplay = '';

            if (hasImprovement) {
                const arrow = delta > 0 ? '↗' : delta < 0 ? '↘' : '→';
                const changeClass = delta > 0 ? 'score-positive' : delta < 0 ? 'score-negative' : 'score-neutral';
                
                displayValue = improvedScore;
                changeDisplay = `
                    <div class="score-change ${changeClass}">
                        <span class="score-arrow">${arrow}</span>
                        <span>${delta > 0 ? '+' : ''}${type === 'gemba' ? delta.toFixed(0) : delta.toFixed(3)}</span>
                        <span class="score-percentage">(${deltaPercent > 0 ? '+' : ''}${deltaPercent.toFixed(1)}%)</span>
                    </div>
                `;
            }

            const percentage = getScorePercentage(type, displayValue);

            return `
                <div class="score-card ${cardClass}" onclick="showScoreInfo('${type}', ${displayValue}, ${originalScore}, ${delta})">
                    <div class="score-label">
                        ${label}
                        <button class="score-info-btn" onclick="event.stopPropagation(); showScoreInfo('${type}', ${displayValue}, ${originalScore}, ${delta})">ℹ</button>
                    </div>
                    <div class="score-main">
                        <div class="score-value">${type === 'gemba' ? displayValue.toFixed(0) : displayValue.toFixed(3)}</div>
                    </div>
                    ${changeDisplay}
                    <div class="score-gauge">
                        <div class="score-fill" style="width: ${percentage}%"></div>
                    </div>
                </div>
            `;
        }

        function createApeImprovement(record) {
            const textDiff = generateTextDiff(record.mt, record.ape);
            
            // 품질 등급 변화 계산 - APE 개선 전후 비교
            // 개선 전 점수로 원래 품질 계산 (Q-score 기반)
            const originalGemba = record.gemba || 0;
            const originalComet = record.comet || 0;
            const originalCos = record.cos || 0;
            const originalQScore = record.q_score;
            const originalTag = record.tag;
            const originalClass = getQualityClassByScores(originalGemba, originalComet, originalCos, originalQScore, originalTag);
            const originalLabel = getQualityLabelByClass(originalClass);
            
            // 개선 후 점수로 개선된 품질 계산 (APE Q-score 우선 사용)
            const improvedGemba = record.gemba + (record.delta_gemba || 0);
            const improvedComet = record.comet + (record.delta_comet || 0);
            const improvedCos = record.cos + (record.delta_cos || 0);
            const apeQScore = record.ape_q_score;
            const apeTag = record.ape_tag;
            const improvedClass = getQualityClassByScores(improvedGemba, improvedComet, improvedCos, apeQScore, apeTag);
            const improvedLabel = getQualityLabelByClass(improvedClass);
            
            const qualityOrder = {
                'quality-very-poor': 1,
                'quality-poor': 2, 
                'quality-good': 3,
                'quality-very-good': 4,
                'quality-excellent': 5
            };
            
            const isQualityImproved = qualityOrder[improvedClass] > qualityOrder[originalClass];
            
            let qualityChangeInfo = '';
            if (isQualityImproved) {
                qualityChangeInfo = `
<div class="quality-change-info" style="margin-bottom: 12px; padding: 8px; background: rgba(0, 208, 132, 0.1); border-radius: 6px; border-left: 3px solid var(--success-color);">
    <div style="font-size: 11px; color: var(--success-color); font-weight: 600;">등급 상승</div>
    <div style="font-size: 12px; color: var(--text-primary);">
        <span class="quality-badge-mini ${originalClass}">${originalLabel}</span>
        <span style="margin: 0 8px; color: var(--success-color);">→</span>
        <span class="quality-badge-mini ${improvedClass}">${improvedLabel}</span>
    </div>
</div>
                `;
            } else if (originalClass !== improvedClass) {
                const isQualityDeclined = qualityOrder[improvedClass] < qualityOrder[originalClass];
                
                if (isQualityDeclined) {
                    qualityChangeInfo = `
<div class="quality-change-info" style="margin-bottom: 12px; padding: 8px; background: rgba(239, 68, 68, 0.1); border-radius: 6px; border-left: 3px solid var(--danger-color);">
    <div style="font-size: 11px; color: var(--danger-color); font-weight: 600;">수정 후 품질 저하 - 원문 검토 권장</div>
    <div style="font-size: 12px; color: var(--text-primary); margin-bottom: 6px;">
        <span class="quality-badge-mini ${originalClass}">${originalLabel}</span>
        <span style="margin: 0 8px; color: var(--danger-color);">→</span>
        <span class="quality-badge-mini ${improvedClass}">${improvedLabel}</span>
    </div>
    <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 8px;">
        번역문 수정에도 불구하고 품질이 저하되었습니다. 원문 자체에 번역하기 어려운 요소가 있을 수 있습니다. 원문 검토를 권장합니다.
    </div>
    <button class="alternative-edit-btn" onclick="suggestSourceImprovement('${record.key}', \`${record.src}\`, \`${record.ape}\`)" style="
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 5px;
        font-size: 10px;
        cursor: pointer;
        transition: all 0.2s;
    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
        <span style="margin-right: 3px;">+</span>원문 개선 제안
    </button>
</div>
                    `;
                } else {
                    qualityChangeInfo = `
<div class="quality-change-info" style="margin-bottom: 12px; padding: 8px; background: rgba(255, 193, 7, 0.1); border-radius: 6px; border-left: 3px solid var(--warning-color);">
    <div style="font-size: 11px; color: var(--warning-color); font-weight: 600;">품질 등급 변화</div>
    <div style="font-size: 12px; color: var(--text-primary);">
        <span class="quality-badge-mini ${originalClass}">${originalLabel}</span>
        <span style="margin: 0 8px; color: var(--warning-color);">→</span>
        <span class="quality-badge-mini ${improvedClass}">${improvedLabel}</span>
    </div>
</div>
                    `;
                }
            } else {
                const originalQScoreValue = originalQScore || 0;
                const improvedQScoreValue = apeQScore || originalQScoreValue;
                const qScoreDelta = improvedQScoreValue - originalQScoreValue;

                const significantQScoreImprovement = qScoreDelta >= 0.1;
                
                if (significantQScoreImprovement) {
                    qualityChangeInfo = `
<div class="quality-change-info" style="margin-bottom: 12px; padding: 8px; background: rgba(59, 130, 246, 0.1); border-radius: 6px; border-left: 3px solid var(--info-color);">
    <div style="font-size: 11px; color: var(--info-color); font-weight: 600;">검토 필요 (소폭 개선)</div>
    <div style="font-size: 12px; color: var(--text-primary); margin-bottom: 4px;">
        <span class="quality-badge-mini ${originalClass}">${originalLabel}</span>
        <span style="margin: 0 8px; color: var(--info-color);">→</span>
        <span class="quality-badge-mini ${improvedClass}">${improvedLabel}</span>
    </div>
    <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 8px;">점수 개선도: ${originalQScoreValue.toFixed(3)} → ${improvedQScoreValue.toFixed(3)} (+${qScoreDelta.toFixed(3)})</div>
    <button class="alternative-edit-btn" onclick="getAlternativeEdit('${record.key}', '${encodeURIComponent(record.src)}', '${encodeURIComponent(record.mt)}', '${record.tag}')" style="
        background: linear-gradient(135deg, var(--info-color), #3b82f6);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 5px;
        font-size: 10px;
        cursor: pointer;
        transition: all 0.2s;
    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
        <span style="margin-right: 3px;">+</span>다른 수정 제안
    </button>
</div>
                    `;
                } else {
                    if (originalClass === improvedClass) {
                        qualityChangeInfo = `
<div class="quality-change-info" style="margin-bottom: 12px; padding: 8px; background: rgba(251, 191, 36, 0.1); border-radius: 6px; border-left: 3px solid #f59e0b;">
    <div style="font-size: 11px; color: #f59e0b; font-weight: 600;">등급 유지</div>
    <div style="font-size: 12px; color: var(--text-primary); margin-bottom: 6px;">
        <span class="quality-badge-mini ${originalClass}">${originalLabel}</span>
        <span style="margin: 0 8px; color: #f59e0b;">→</span>
        <span class="quality-badge-mini ${improvedClass}">${improvedLabel}</span>
    </div>
    <button class="alternative-edit-btn" onclick="getAlternativeEdit('${record.key}', '${encodeURIComponent(record.src)}', '${encodeURIComponent(record.mt)}', '${record.tag}')" style="
        background: linear-gradient(135deg, #f59e0b, #d97706);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 5px;
        font-size: 10px;
        cursor: pointer;
        transition: all 0.2s;
    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
        <span style="margin-right: 3px;">+</span>다른 수정 제안
    </button>
</div>
                        `;
                    } else {
                        qualityChangeInfo = '';
                    }
                }
            }
            
            return `
<div class="ape-improvement">
    <div class="ape-header">
        <span class="ape-icon icon icon-improve"></span>
        <span class="ape-title">수정 제안</span>
    </div>
    ${qualityChangeInfo}
    <div class="text-content text-diff">${textDiff}</div>
</div>
            `;
        }

        function generateTextDiff(original, improved) {
            if (!original || !improved || original === improved) {
                return improved || original || 'N/A';
            }

            const originalWords = original.split(' ');
            const improvedWords = improved.split(' ');
            
            if (originalWords.join(' ') === improvedWords.join(' ')) {
                return improved;
            }

            return `
                <span class="diff-original">${original}</span>
                <span class="diff-improved">${improved}</span>
            `;
        }

        function createEvidenceIndicator(record) {
            const evidence = record.flag?.gemba_reason || '';
            const hasEvidence = evidence && evidence.trim().length > 0;
            
            if (!hasEvidence) return '';
            
            const isHighQuality = record.tag === 'strict_pass';
            const currentQuality = getQualityClass(record);
            const isExcellentOrVeryGood = currentQuality === 'quality-excellent' || currentQuality === 'quality-very-good';
            
            if (isHighQuality && isExcellentOrVeryGood) {
                return ''; 
            }
            
            const isFailRecord = record.tag === 'fail';
            const isCritical = evidence.toLowerCase().includes('error') || 
                              evidence.toLowerCase().includes('incorrect') ||
                              evidence.toLowerCase().includes('wrong');
            
            let iconClass = 'info';
            if (isFailRecord) iconClass = 'critical';
            else if (isCritical) iconClass = 'critical';
            
            const iconText = iconClass === 'critical' ? '!' : 'i';
            
            return `
<div class="evidence-indicator" data-evidence="${encodeURIComponent(evidence)}" data-type="${iconClass}" onmouseenter="showEvidenceTooltipFromData(this)" onmouseleave="hideEvidenceTooltip(this)">
    <div class="evidence-icon ${iconClass}">${iconText}</div>
    <div class="evidence-tooltip">
        <strong>평가 근거:</strong><br>
        <span class="evidence-text"></span>
    </div>
</div>
            `;
        }

        function showEvidenceTooltipFromData(element) {
            const evidenceEncoded = element.getAttribute('data-evidence');
            const type = element.getAttribute('data-type');
            const evidence = decodeURIComponent(evidenceEncoded);
            
            // 툴팁 내용 업데이트
            const evidenceText = element.querySelector('.evidence-text');
            evidenceText.textContent = evidence;
            
            showEvidenceTooltip(element, evidence, type);
        }

        function showEvidenceTooltip(element, evidence, type) {
            const tooltip = element.querySelector('.evidence-tooltip');
            const icon = element.querySelector('.evidence-icon');
            
            tooltip.style.visibility = 'hidden';
            tooltip.style.opacity = '1';
            tooltip.classList.add('show');
            
            const iconRect = icon.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            const tooltipWidth = Math.min(tooltipRect.width, 400); // 최대 400px
            const tooltipHeight = tooltipRect.height;
            
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            let left = iconRect.left + iconRect.width / 2 - tooltipWidth / 2;
            let top = iconRect.top - tooltipHeight - 10;
            
            if (left < 10) left = 10;
            if (left + tooltipWidth > viewportWidth - 10) left = viewportWidth - tooltipWidth - 10;
            
            if (top < 10) {
                top = iconRect.bottom + 10;
                if (top + tooltipHeight > viewportHeight - 10) {
                    top = viewportHeight - tooltipHeight - 10;
                }
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.style.width = tooltipWidth + 'px';
            tooltip.style.visibility = 'visible';
        }

        function hideEvidenceTooltip(element) {
            const tooltip = element.querySelector('.evidence-tooltip');
            tooltip.classList.remove('show');
            tooltip.style.left = '';
            tooltip.style.top = '';
            tooltip.style.width = '';
            tooltip.style.visibility = '';
        }

        function showScoreInfo(scoreType, currentValue, originalValue, delta) {
            const scoreInfos = {
                'gemba': {
                    name: 'GEMBA',
                    description: 'LLM 기반 번역품질 평가 점수',
                    range: '0-100점',
                    interpretation: '90+ 매우우수, 75+ 우수, 60+ 양호, 40+ 나쁨, 40미만 매우나쁨',
                    usage: '의미·문맥·유창성 등을 참조번역 없이 번역 품질을 사람처럼 채점·분류하게 하는 프롬포트 기반 메트릭입니다.\n LLM의 언어 이해 능력을 활용해 판단함으로 사람 평가와 가장 높은 유사도를 지닙니다.',
                    analysis: '• 85점 이상: 게시/출간 가능한 고품질 번역\n• 75-84점: 경미한 후편집 필요\n• 65-74점: 상당한 후편집 필요\n• 45-64점: 재번역 권장\n• 45점 미만: 심각한 품질 문제',
                    qualityScale: [
                        { range: '90-100', description: '**매우우수**: 원문 의미를 완벽히 반영하며, 인간 번역과 거의 구분되지 않음' },
                        { range: '75-89', description: '**우수**: 명확하고 자연스러운 번역으로 실사용 가능한 수준, 단 톤이나 스타일 측면에서 경미한 수정이 필요할 수 있음' },
                        { range: '60-74', description: '**양호**: 주요 의미는 전달되나 어색한 표현, 문법 오류 등이 존재. 가벼운 후편집이 필요하며, 바로 사용하기엔 아쉬움이 있음' },
                        { range: '50-59', description: '**나쁨**: 의미 왜곡, 문법 오류가 다수 포함됨. 원문 의도가 불분명해질 수 있어 전면적인 수정 혹은 재번역 필요' },
                        { range: '0-49', description: '**매우나쁨**: 문장이 의미를 이해하기 어려운 수준으로 부정확하거나 부자연스러움. 재번역 필수' }
                    ]
                },
                'comet': {
                    name: 'COMET', 
                    description: '다국어 트랜스포머 기반의 품질 예측 모델',
                    range: '0.0-1.0 (실제 0.2-0.9)',
                    interpretation: '0.80+ 매우우수, 0.75+ 우수, 0.70+ 양호, 0.50+ 나쁨, 0.50미만 매우나쁨',
                    usage: 'InfoXLM 기반 번역 품질 예측 모델입니다. 원문과 번역문을 입력받아 별도의 참조번역 없이 번역 품질을 점수로 반환합니다.\n 임베딩 벡터의 거리만으로 평가하는게 아닌, 인간이 매긴 품질 점수와 일치하도록 학습하여 사람 평가와 높은 유사도를 지닙니다.',
                    analysis: '• 0.80+: 인간 수준의 번역 품질\n• 0.75-0.79: 실용적 사용 가능\n• 0.70-0.74: 이해 가능하나 개선 필요\n• 0.50-0.69: 품질 문제 심각\n• 0.50 미만: 사용 불가 수준',
                    qualityScale: [
                        { range: '0.85-1.0', description: '**매우우수**: 인간 번역과 거의 구분되지 않음.' },
                        { range: '0.75-0.84', description: '**우수**: 명확하고 자연스러운 번역으로 실사용 가능한 수준, 단 톤이나 스타일 측면에서 경미한 수정이 필요할 수 있음' },
                        { range: '0.65-0.74', description: '**양호**: 주요 의미 전달은 가능하나 표현이나 문법이 어색할 수 있음. 후편집 권장' },
                        { range: '0.50-0.64', description: '**나쁨**: 의미 왜곡, 문법 오류가 다수 포함됨. 명확한 의도 전달을 위해 재번역 필요' },
                        { range: '0.0-0.49', description: '**매우나쁨**: 문장의 의미를 파악하기 어려움. 재번역 필수' }
                    ]
                },
                'cos': {
                    name: 'Cosine Similarity',
                    description: 'LaBSE 임베딩 벡터 간 코사인 유사도 계산',
                    range: '0.0-1.0 (실제 0.5-0.95)',
                    interpretation: '0.85+ 매우우수, 0.75+ 우수, 0.70+ 양호, 0.50+ 나쁨, 0.50미만 매우나쁨',
                    usage: 'LaBSE 다국어 임베딩 모델을 사용하여 한국어와 영어 문장을 공통의 의미공간에서 벡터화합니다. 두 언어 간 문장의 유사도를 직접 비교하여 원문과 번역문 간 의미적 일치 정도를 평가합니다.',
                    analysis: '• 0.85+: 의미 보존 탁월\n• 0.75-0.84: 핵심 의미 보존\n• 0.70-0.74: 일부 의미 손실\n• 0.50-0.69: 의미 왜곡 위험\n• 0.50 미만: 심각한 의미 손실',
                    qualityScale: [
                        { range: '0.85-1.0', description: '**매우우수**: 번역 문장이 원문과 의미적으로 거의 완벽하게 일치함. 번역의 오역이나 의미 왜곡 가능성이 극히 낮음' },
                        { range: '0.75-0.84', description: '**우수**: 핵심 의미는 보존됨. 문장 구조나 세부 어휘에 약간의 차이가 있을 수 있으나, 전체적인 의미를 전달하는데 문제없음' },
                        { range: '0.70-0.74', description: '**양호**: 일부 의미 손실이나 약간의 늬앙스 차이가 존재할 수 있음. 단어선택같은 가벼운 후편집 권장' },
                        { range: '0.50-0.69', description: '**나쁨**: 번역문과 원문간의 의미 차이가 있음. 재번역 권장' },
                        { range: '0.0-0.49', description: '**매우나쁨**: 원문과 번역문의 연관성이 없음. 번역자체가 안됐거나 원문-번역문 매핑이 안되어있을 수 있음. 재번역 필수' }
                    ]
                }
            };

            const info = scoreInfos[scoreType];
            if (!info) return;

            // 모달 타이틀 설정
            document.getElementById('scoreModalTitle').textContent = info.name + ' 상세 정보';
            
            // 헤더 색상을 점수 타입에 따라 동적으로 설정
            const header = document.querySelector('.score-info-header');
            const colorMap = {
                'gemba': 'linear-gradient(135deg, #10b981, #34d399)',
                'comet': 'linear-gradient(135deg, #10b981, #34d399)',
                'cos': 'linear-gradient(135deg, #10b981, #34d399)'    
            };
            header.style.background = colorMap[scoreType] || 'linear-gradient(135deg, #10b981, #34d399)';
            
            // 현재 점수 표시
            document.getElementById('scoreCurrentValue').textContent = 
                scoreType === 'gemba' ? currentValue.toFixed(0) : currentValue.toFixed(3);
            document.getElementById('scoreCurrentLabel').textContent = info.name.toUpperCase();

            // 개선 정보 표시 (APE가 적용된 경우에만)
            const improvementInfo = document.getElementById('scoreImprovementInfo');
            if (delta !== 0 && originalValue !== null) {
                improvementInfo.style.display = 'block';
                
                const deltaElement = document.getElementById('deltaValue');
                deltaElement.textContent = (delta > 0 ? '+' : '') + 
                    (scoreType === 'gemba' ? delta.toFixed(0) : delta.toFixed(3));
                deltaElement.className = `value ${delta > 0 ? 'positive' : 'negative'}`;
                
                document.getElementById('beforeValue').textContent = 
                    scoreType === 'gemba' ? originalValue.toFixed(0) : originalValue.toFixed(3);
                document.getElementById('afterValue').textContent = 
                    scoreType === 'gemba' ? currentValue.toFixed(0) : currentValue.toFixed(3);
            } else {
                improvementInfo.style.display = 'none';
            }

            // 품질 평가 기준 생성 (테이블 형식)
            const qualityScale = document.getElementById('qualityScale');
            qualityScale.innerHTML = `
                <table style="
                    width: 100%; 
                    border-collapse: collapse; 
                    margin-top: 12px; 
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    border-radius: 8px;
                    overflow: hidden;
                ">
                    <thead>
                        <tr style="
                            background: var(--accent-bg); 
                            border-bottom: 1px solid var(--border-color);
                        ">
                            <th style="
                                padding: 16px 20px; 
                                border: none; 
                                text-align: center; 
                                font-weight: 700; 
                                color: var(--text-primary); 
                                font-size: 15px;
                                white-space: nowrap;
                                min-width: 120px;
                            ">점수 범위</th>
                            <th style="
                                padding: 16px 20px; 
                                border: none; 
                                text-align: left; 
                                font-weight: 700; 
                                color: var(--text-primary); 
                                font-size: 15px;
                            ">품질 등급 및 설명</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${info.qualityScale.map((item, index) => `
                            <tr style="
                                border-bottom: 1px solid var(--border-color);
                                background: var(--card-bg);
                            ">
                                <td style="
                                    padding: 16px 20px; 
                                    border: none; 
                                    text-align: center; 
                                    font-weight: 700; 
                                    color: var(--text-primary); 
                                    font-size: 14px; 
                                    white-space: nowrap;
                                    min-width: 120px;
                                    border-right: 1px solid var(--border-color);
                                ">${item.range}</td>
                                <td style="
                                    padding: 16px 20px; 
                                    border: none; 
                                    text-align: left; 
                                    color: var(--text-secondary); 
                                    font-size: 14px; 
                                    line-height: 1.6;
                                    word-break: keep-all;
                                    white-space: pre-wrap;
                                ">${item.description.replace(/\*\*(.*?)\*\*:/g, '<strong style="color: var(--text-primary);">$1:</strong>')}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            // 세부 정보 설명 (기존 활용방법을 세부정보로 변경)
            document.getElementById('evaluationMethod').innerHTML = `
                <div style="margin-bottom: 16px;">
                    <strong style="color: var(--text-primary); font-weight: 700; font-size: 15px;">설명:</strong>
                    <div style="margin-top: 8px; font-size: 18px; line-height: 1.5; color: var(--text-secondary);">${info.description}</div>
                </div>
                <div>
                    <strong style="color: var(--text-primary); font-weight: 700; font-size: 15px;">세부 정보:</strong>
                    <div style="margin-top: 8px; font-size: 14px; line-height: 1.6; color: var(--text-secondary);">${info.usage}</div>
                </div>
            `;

            // 모달 표시
            const modal = document.getElementById('scoreInfoModal');
            modal.classList.add('show');
        }

        function closeScoreInfoModal() {
            const modal = document.getElementById('scoreInfoModal');
            modal.classList.remove('show');
        }

        // 모달 외부 클릭 시 닫기
        document.getElementById('scoreInfoModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeScoreInfoModal();
            }
        });

        function getQualityClass(record) {
            // APE 개선 후의 점수를 사용 (개선이 있다면 개선 후, 없다면 원본)
            const hasApe = record.ape && record.ape !== record.mt && 
                          (record.delta_comet || record.delta_cos || record.delta_gemba);
            
            if (hasApe) {
                // APE 개선 후에는 APE Q-score 사용 (있는 경우)
                const gemba = record.ape_gemba || ((record.gemba || 0) + (record.delta_gemba || 0));
                const comet = (record.comet || 0) + (record.delta_comet || 0);
                const cos = (record.cos || 0) + (record.delta_cos || 0);
                const apeQScore = record.ape_q_score;
                const apeTag = record.ape_tag;
                const gembaReason = record.flag?.gemba_reason; // APE 후에는 보통 no_parse 해결됨
                
                return getQualityClassByScores(gemba, comet, cos, apeQScore, apeTag, gembaReason);
            } else {
                // APE 개선이 없는 경우 원본 Q-score 사용
                const gemba = record.gemba || 0;
                const comet = record.comet || 0;
                const cos = record.cos || 0;
                const qScore = record.q_score;
                const tag = record.tag;
                const gembaReason = record.flag?.gemba_reason;
                
                return getQualityClassByScores(gemba, comet, cos, qScore, tag, gembaReason);
            }
        }

        function getQualityClassByScores(gemba, comet, cos, qScore = null, tag = null, gembaReason = null) {
            // Q-score 기반 품질등급 (2단계 검증: 하한게이트 + Q-밴드)
            
            // 1. 하한 게이트 검사 (절대값 기준)
            const actualGemba = (gembaReason !== "no_parse") ? gemba : 0.0;
            const isNoParse = (gembaReason === "no_parse");
            if (checkFailGate(cos, comet, actualGemba, isNoParse)) {
                return 'quality-poor';  // 하한 게이트 실패 -> 나쁨
            }
            
            // 2. Q-score 값이 있는 경우 사용 (업데이트된 임계값)
            // 하한게이트를 통과했으므로 최소한 "poor" 등급 보장
            if (qScore !== null && qScore !== undefined) {
                if (qScore >= 0.6) {
                    return 'quality-excellent';    // 0.6 이상 -> 매우우수
                } else if (qScore >= 0.25) {
                    return 'quality-very-good';    // 0.25 이상 -> 우수
                } else if (qScore >= -0.1) {
                    return 'quality-good';         // -0.1 이상 -> 양호
                } else if (qScore >= -0.6) {
                    return 'quality-poor';         // -0.6 이상 -> 나쁨
                } else {
                    // 하한게이트 통과했지만 Q-score가 매우 낮은 경우 -> "나쁨"으로 상향
                    return 'quality-poor';         // 매우나쁨 -> 나쁨으로 상향
                }
            }
            
            // 3. Q-score가 없는 경우 기본값 (no_parse 포함)
            console.warn('Q-score 데이터 누락:', { gemba, comet, cos, qScore, tag, gembaReason });
            return 'quality-poor';  // 기본값: 나쁨
        }

        // 하한 게이트 검사 함수
        function checkFailGate(cos, comet, gemba, isNoParse = false) {
            const FAIL_GATE_CONDITIONS = {
                cos: 0.50,
                comet: 0.50,
                gemba: 50
            };
            
            // comet과 cos는 항상 검사
            if (cos < FAIL_GATE_CONDITIONS.cos) return true;
            if (comet < FAIL_GATE_CONDITIONS.comet) return true;
            // gemba는 no_parse가 아닐 때만 검사
            if (!isNoParse && gemba < FAIL_GATE_CONDITIONS.gemba) return true;
            return false;
        }

        function getQualityLabel(record) {
            const qualityClass = getQualityClass(record);
            const labels = {
                'quality-excellent': '매우우수',
                'quality-very-good': '우수',
                'quality-good': '양호',
                'quality-poor': '나쁨',
                'quality-very-poor': '매우나쁨'
            };
            return labels[qualityClass] || '미분류';
        }

        function getQualityLabelByClass(qualityClass) {
            const labels = {
                'quality-excellent': '매우우수',
                'quality-very-good': '우수',
                'quality-good': '양호',
                'quality-poor': '나쁨',
                'quality-very-poor': '매우나쁨'
            };
            return labels[qualityClass] || '미분류';
        }

        function createQualityBadge(record) {
            const hasApe = record.ape && record.ape !== record.mt && 
                          (record.delta_comet || record.delta_cos || record.delta_gemba);
                          
            if (!hasApe) {
                // APE 개선이 없는 경우 - 기존 방식
                const qualityClass = getQualityClass(record);
                const qualityLabel = getQualityLabel(record);
                return `<div class="quality-badge ${qualityClass}">${qualityLabel}</div>`;
            }
            
            // APE 개선이 있는 경우 - 개선 전후 표시
            // 원본 등급 계산 (APE 적용 전)
            const originalGemba = record.gemba || 0;
            const originalComet = record.comet || 0;
            const originalCos = record.cos || 0;
            const originalQScore = record.q_score;
            const originalTag = record.tag;
            const originalGembaReason = record.flag?.gemba_reason;
            
            const originalClass = getQualityClassByScores(originalGemba, originalComet, originalCos, originalQScore, originalTag, originalGembaReason);
            const originalLabel = getQualityLabelByClass(originalClass);
            
            const improvedGemba = record.ape_gemba || ((record.gemba || 0) + (record.delta_gemba || 0));
            const improvedComet = record.comet + (record.delta_comet || 0);
            const improvedCos = record.cos + (record.delta_cos || 0);
            const apeQScore = record.ape_q_score;
            const apeTag = record.ape_tag;
            
            const improvedClass = getQualityClassByScores(improvedGemba, improvedComet, improvedCos, apeQScore, apeTag);
            const improvedLabel = getQualityLabelByClass(improvedClass);
            
            const qualityOrder = {
                'quality-very-poor': 1,
                'quality-poor': 2, 
                'quality-good': 3,
                'quality-very-good': 4,
                'quality-excellent': 5
            };
            
            const isImproved = qualityOrder[improvedClass] > qualityOrder[originalClass];
            
            if (isImproved) {
                return `
                    <div class="quality-badge-improved">
                        <div class="quality-badge ${improvedClass}">${improvedLabel}</div>
                        <div class="quality-improvement-arrow">▲</div>
                        <div class="quality-badge-original ${originalClass}">${originalLabel}</div>
                    </div>
                `;
            } else {
                // 개선되지 않았으면 기존 방식
                return `<div class="quality-badge ${originalClass}">${originalLabel}</div>`;
            }
        }

        function getScorePercentage(scoreType, value) {
            let min, max;
            switch(scoreType) {
                case 'gemba':
                    min = 20; max = 100;
                    break;
                case 'comet':
                    min = 0.2; max = 0.9;
                    break;
                case 'cos':
                    min = 0.5; max = 0.95;
                    break;
                default:
                    return 50;
            }
            
            return Math.min(100, Math.max(0, ((value - min) / (max - min)) * 100));
        }

        function refreshData() {
            resetPagination();
            loadHeaderStats();
            loadRecords();
        }

        function exportData() {
            if (!currentData || currentData.length === 0) {
                alert('내보낼 데이터가 없습니다.');
                return;
            }

            const csv = convertToCSV(currentData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', `mt_quality_analysis_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function convertToCSV(data) {
            const headers = ['Key', 'Source', 'MT', 'APE', 'GEMBA', 'COMET', 'COS', 'Tag', 'Bucket'];
            const rows = data.map(record => [
                record.key || '',
                record.src || '',
                record.mt || '',
                record.ape || '',
                record.gemba || '',
                record.comet || '',
                record.cos || '',
                record.tag || '',
                record.bucket || ''
            ]);

            return [headers, ...rows].map(row => 
                row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')
            ).join('\n');
        }

        // 차트 모달 표시 함수들
        async function showStatsChart(chartType) {
            const modal = document.getElementById('statsModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');
            
            // 모달 타이틀 설정
            const titles = {
                'records': '총 레코드 분석',
                'pass-rate': '품질 통과율 분석',
                'ape-effect': '수정 효과 분석'
            };
            modalTitle.textContent = titles[chartType] || '통계 분석';
            
            // 로딩 표시
            modalContent.innerHTML = '<div class="loading"><div class="spinner"></div>차트 생성 중...</div>';
            modal.classList.add('show');
            
            try {
                // API에서 분석 데이터 가져오기
                const response = await fetch(`${API_BASE}/analytics`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Analytics data received:', data); // 디버깅용
                
                // 차트 타입별로 다른 내용 생성
                let chartHTML = '';
                switch(chartType) {
                    case 'records':
                        chartHTML = generateRecordsChart(data);
                        break;
                    case 'pass-rate':
                        chartHTML = await generatePassRateChart(data);
                        break;
                    case 'ape-effect':
                        chartHTML = await generateApeEffectChart(data);
                        break;
                    default:
                        chartHTML = '<div class="loading">알 수 없는 차트 타입입니다.</div>';
                }
                
                modalContent.innerHTML = chartHTML;
                
                if (chartType === 'pass-rate') {
                    initDonutTooltips(modalContent);
                }
            } catch (error) {
                console.error('차트 데이터 로드 실패:', error);
                modalContent.innerHTML = `
                    <div class="loading">
                        ❌ 차트 데이터 로드에 실패했습니다.<br>
                        <small style="color: var(--text-muted); margin-top: 8px; display: block;">
                            오류: ${error.message}<br>
                            API 서버가 실행 중인지 확인해주세요.
                        </small>
                    </div>`;
            }
        }

        function generateRecordsChart(data) {
            const totalRecords = data.total_records;
            const bucketDistribution = data.distributions.buckets || {};
            
            // 버킷 이름을 더 이해하기 쉽게 변환
            const bucketLabels = {
                'very_short': '매우 짧음',
                'short': '짧음',
                'medium': '보통',
                'long': '긺',
                'very_long': '매우 긺'
            };
            
            const buckets = Object.entries(bucketDistribution).map(([name, count]) => ({
                name: bucketLabels[name] || name,
                originalName: name,
                count: count,
                percentage: (count / totalRecords * 100).toFixed(1)
            }));
            
            // 정렬 (길이 순서대로)
            const bucketOrder = ['very_short', 'short', 'medium', 'long', 'very_long'];
            buckets.sort((a, b) => {
                const aIndex = bucketOrder.indexOf(a.originalName);
                const bIndex = bucketOrder.indexOf(b.originalName);
                return aIndex - bIndex;
            });
            
            // 차트를 위한 최대값 계산 (0이 아닌 최소값 보장)
            const maxCount = Math.max(...buckets.map(b => b.count), 1);
            
            return `
                <div class="chart-grid">
                    <div class="chart-stat">
                        <div class="chart-stat-value">${totalRecords.toLocaleString()}</div>
                        <div class="chart-stat-label">총 레코드 수</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value">${buckets.length}</div>
                        <div class="chart-stat-label">길이 분류</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value">${buckets.reduce((max, bucket) => bucket.count > max.count ? bucket : max, buckets[0])?.name || 'N/A'}</div>
                        <div class="chart-stat-label">최다 분류</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h3 style="margin-bottom: 15px; color: var(--text-primary); text-align: center; font-weight: 600;">텍스트 길이별 레코드 분포</h3>
                    <div class="compact-bar-chart" style="
                        display: flex; 
                        align-items: flex-end; 
                        justify-content: space-around; 
                        height: 200px; 
                        padding: 15px 20px 10px 20px; 
                        background: var(--card-bg);
                        border-radius: 12px; 
                        border: 1px solid var(--border-color);
                        position: relative;
                        box-shadow: var(--shadow-medium);
                        overflow: hidden;
                    ">
                        <!-- 배경 그리드 -->
                        <div style="
                            position: absolute;
                            top: 15px;
                            left: 20px;
                            right: 20px;
                            bottom: 40px;
                            background-image: 
                                linear-gradient(to right, var(--border-color) 1px, transparent 1px),
                                linear-gradient(to bottom, var(--border-color) 1px, transparent 1px);
                            background-size: 25px 25px;
                            opacity: 0.2;
                            pointer-events: none;
                        "></div>
                        
                        ${buckets.map((bucket, index) => {
                            // 컴팩트한 높이 계산 - 최소 20px, 최대 120px
                            const minHeight = 20;
                            const maxHeight = 120;
                            const percentage = maxCount > 0 ? (bucket.count / maxCount) : 0;
                            const calculatedHeight = bucket.count === 0 ? 10 : Math.max(minHeight, percentage * maxHeight);
                            const color = getColorByBucket(bucket.originalName);
                            
                            return `
                                <div style="
                                    display: flex; 
                                    flex-direction: column; 
                                    align-items: center; 
                                    justify-content: flex-end;
                                    height: 100%;
                                    flex: 1; 
                                    max-width: 70px;
                                    z-index: 1;
                                ">
                                    <!-- 바차트 (하단에서 위로) -->
                                    <div style="
                                        width: 45px;
                                        height: ${calculatedHeight}px;
                                        background: ${color};
                                        border-radius: 6px 6px 2px 2px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        color: var(--text-primary);
                                        font-weight: 700;
                                        font-size: ${bucket.count > 999 ? '9px' : '11px'};
                                        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
                                        position: relative;
                                        transition: all 0.3s ease;
                                        cursor: pointer;
                                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                        animation: growBar 0.8s ease-out ${index * 0.1}s both;
                                        margin-bottom: 5px;
                                    " onmouseover="this.style.transform='scale(1.1) translateY(-2px)'; this.style.filter='brightness(1.2)';" onmouseout="this.style.transform='scale(1) translateY(0)'; this.style.filter='brightness(1)';">
                                        ${bucket.count > 0 ? bucket.count.toLocaleString() : '0'}
                                    </div>
                                    
                                    <!-- 라벨 (컨테이너 최하단) -->
                                    <div style="
                                        text-align: center;
                                        font-weight: 500;
                                        color: var(--text-primary);
                                        font-size: 10px;
                                        line-height: 1.1;
                                        margin-bottom: 0;
                                    ">
                                        ${bucket.name}
                                        <br>
                                        <span style="
                                            font-size: 9px; 
                                            color: var(--text-muted);
                                            font-weight: 400;
                                        ">${bucket.percentage}%</span>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                    </div>
                </div>
            `;
        }

        function getColorByBucket(bucketName) {
            const colors = {
                'very_short': 'var(--danger-color)',   // 빨강 - 매우 짧음
                'short': 'var(--warning-color)',       // 주황 - 짧음  
                'medium': 'var(--info-color)',         // 파랑 - 보통
                'long': 'var(--success-color)',        // 초록 - 긺
                'very_long': '#8b5cf6'                 // 보라 - 매우 긺
            };
            return colors[bucketName] || 'var(--neutral-color)'; // 기본값: 회색
        }

        async function generatePassRateChart(data) {
            const total = data.total_records;
            
            // API에서 before/after 품질분포 데이터 가져오기
            const qualityDist = data.quality_distribution || {};
            const beforeDist = qualityDist.before || {};
            const afterDist = qualityDist.after || {};
            
            // Before APE 데이터
            const beforeVeryPoor = beforeDist.very_poor || 0;
            const beforePoor = beforeDist.poor || 0;
            const beforeGood = beforeDist.good || 0;
            const beforeVeryGood = beforeDist.very_good || 0;
            const beforeExcellent = beforeDist.excellent || 0;
            
            // After APE 데이터
            const afterVeryPoor = afterDist.very_poor || 0;
            const afterPoor = afterDist.poor || 0;
            const afterGood = afterDist.good || 0;
            const afterVeryGood = afterDist.very_good || 0;
            const afterExcellent = afterDist.excellent || 0;
            
            // 통계 계산
            const beforePassRate = (((beforeGood + beforeVeryGood + beforeExcellent) / total) * 100).toFixed(1);
            const afterPassRate = (((afterGood + afterVeryGood + afterExcellent) / total) * 100).toFixed(1);
            const beforeExcellentRate = (((beforeVeryGood + beforeExcellent) / total) * 100).toFixed(1);
            const afterExcellentRate = (((afterVeryGood + afterExcellent) / total) * 100).toFixed(1);
            const beforeFailRate = (((beforeVeryPoor + beforePoor) / total) * 100).toFixed(1);
            const afterFailRate = (((afterVeryPoor + afterPoor) / total) * 100).toFixed(1);
            
            // 개선률 계산
            const passRateImprovement = (afterPassRate - beforePassRate).toFixed(1);
            const excellentRateImprovement = (afterExcellentRate - beforeExcellentRate).toFixed(1);
            const failRateReduction = (beforeFailRate - afterFailRate).toFixed(1);
            
            return `
                <div class="chart-grid">
                    <div class="chart-stat">
                        <div class="chart-stat-value">${afterPassRate}%</div>
                        <div class="chart-stat-label">통과율</div>
                        <div class="chart-stat-change" style="color: ${passRateImprovement >= 0 ? '#22c55e' : '#ef4444'};">
                            ${passRateImprovement >= 0 ? '+' : ''}${passRateImprovement}%p
                        </div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value">${afterExcellentRate}%</div>
                        <div class="chart-stat-label">우수등급율</div>
                        <div class="chart-stat-change" style="color: ${excellentRateImprovement >= 0 ? '#22c55e' : '#ef4444'};">
                            ${excellentRateImprovement >= 0 ? '+' : ''}${excellentRateImprovement}%p
                        </div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="color: #ef4444;">${afterFailRate}%</div>
                        <div class="chart-stat-label">품질미달율</div>
                        <div class="chart-stat-change" style="color: ${failRateReduction >= 0 ? '#22c55e' : '#ef4444'};">
                            ${failRateReduction >= 0 ? '-' : '+'}${Math.abs(failRateReduction)}%p
                        </div>
                    </div>
                </div>
                
                <!-- 품질등급 비교 차트 -->
                <div class="quality-comparison-container" style="margin-top: 24px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 32px;">
                        <!-- APE 이전 품질등급표 카드 -->
                        <div class="quality-chart-card" style="background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                            <div class="card-header" style="text-align: center; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border);">
                                <h3 style="margin: 0; color: var(--text-primary); font-size: 18px; font-weight: 600;">수정 이전 품질등급</h3>
                                <p style="margin: 8px 0 0 0; color: var(--text-secondary); font-size: 14px;">총 ${total}건</p>
                            </div>
                            <div class="donut-chart-wrapper" style="display: flex; justify-content: center; position: relative;">
                                <svg class="donut-svg" viewBox="0 0 200 200" style="width: 200px; height: 200px;">
                                    ${generateDonutChartWithTooltip([
                                        { label: '매우우수', value: beforeExcellent, color: '#059669' },
                                        { label: '우수', value: beforeVeryGood, color: '#10b981' },
                                        { label: '양호', value: beforeGood, color: '#f59e0b' },
                                        { label: '나쁨', value: beforePoor, color: '#f97316' },
                                        { label: '매우나쁨', value: beforeVeryPoor, color: '#dc2626' }
                                    ].filter(item => item.value > 0), total, 'before')}
                                </svg>
                                <div id="donut-tooltip-before" class="donut-tooltip" style="position: absolute; background: rgba(0,0,0,0.88); color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; pointer-events: none; opacity: 0; transform: translateY(-8px); transition: all 0.25s ease; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.25); max-width: 250px;"></div>
                            </div>
                        </div>
                        
                        <!-- APE 이후 품질등급표 카드 -->
                        <div class="quality-chart-card" style="background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                            <div class="card-header" style="text-align: center; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border);">
                                <h3 style="margin: 0; color: var(--text-primary); font-size: 18px; font-weight: 600;">수정 이후 품질등급</h3>
                                <p style="margin: 8px 0 0 0; color: var(--text-secondary); font-size: 14px;">총 ${total}건</p>
                            </div>
                            <div class="donut-chart-wrapper" style="display: flex; justify-content: center; position: relative;">
                                <svg class="donut-svg" viewBox="0 0 200 200" style="width: 200px; height: 200px;">
                                    ${generateDonutChartWithTooltip([
                                        { label: '매우우수', value: afterExcellent, color: '#059669' },
                                        { label: '우수', value: afterVeryGood, color: '#10b981' },
                                        { label: '양호', value: afterGood, color: '#f59e0b' },
                                        { label: '나쁨', value: afterPoor, color: '#f97316' },
                                        { label: '매우나쁨', value: afterVeryPoor, color: '#dc2626' }
                                    ].filter(item => item.value > 0), total, 'after', [
                                        { label: '매우우수', beforeValue: beforeExcellent, afterValue: afterExcellent },
                                        { label: '우수', beforeValue: beforeVeryGood, afterValue: afterVeryGood },
                                        { label: '양호', beforeValue: beforeGood, afterValue: afterGood },
                                        { label: '나쁨', beforeValue: beforePoor, afterValue: afterPoor },
                                        { label: '매우나쁨', beforeValue: beforeVeryPoor, afterValue: afterVeryPoor }
                                    ])}
                                </svg>
                                <div id="donut-tooltip-after" class="donut-tooltip" style="position: absolute; background: rgba(0,0,0,0.88); color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; pointer-events: none; opacity: 0; transform: translateY(-8px); transition: all 0.25s ease; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.25); max-width: 250px;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 간소화된 범례 -->
                    <div class="quality-legend-simplified" style="background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin-top: 20px;">
                        <div class="legend-inline" style="display: flex; justify-content: center; align-items: center; gap: 32px; flex-wrap: wrap;">
                            ${[
                                { label: '매우우수', beforeValue: beforeExcellent, afterValue: afterExcellent, color: '#059669' },
                                { label: '우수', beforeValue: beforeVeryGood, afterValue: afterVeryGood, color: '#10b981' },
                                { label: '양호', beforeValue: beforeGood, afterValue: afterGood, color: '#f59e0b' },
                                { label: '나쁨', beforeValue: beforePoor, afterValue: afterPoor, color: '#f97316' },
                                { label: '매우나쁨', beforeValue: beforeVeryPoor, afterValue: afterVeryPoor, color: '#dc2626' }
                            ].map(item => `
                                <div class="legend-item-compact" style="display: flex; align-items: center; gap: 8px;">
                                    <div class="legend-dot" style="width: 14px; height: 14px; border-radius: 50%; background-color: ${item.color}; flex-shrink: 0;"></div>
                                    <span style="color: var(--text-primary); font-weight: 500; font-size: 14px;">${item.label}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        async function generateApeEffectChart(data) {
            const apeData = data.ape_effectiveness || {};
            const tagsData = data.distributions.tags || {};
            
            // APE 데이터 정확하게 추출 - 모든 메트릭 (안전한 숫자 변환)
            let avgGembaImprovement = 0;
            let avgCometImprovement = 0;
            let avgCosineImprovement = 0;
            let recordsWithApe = 0;
            
            // 디버깅용 로그 추가
            console.log('APE 효과 데이터:', apeData);
            
            if (apeData.avg_gemba_improvement !== undefined && apeData.avg_gemba_improvement !== null) {
                avgGembaImprovement = Number(apeData.avg_gemba_improvement) || 0;
                console.log('GEMBA 개선도:', avgGembaImprovement);
            }
            if (apeData.avg_comet_improvement !== undefined && apeData.avg_comet_improvement !== null) {
                avgCometImprovement = (Number(apeData.avg_comet_improvement) || 0) * 100;
                console.log('COMET 개선도:', avgCometImprovement);
            }
            if (apeData.avg_cosine_improvement !== undefined && apeData.avg_cosine_improvement !== null) {
                avgCosineImprovement = (Number(apeData.avg_cosine_improvement) || 0) * 100;
                console.log('COS 개선도:', avgCosineImprovement);
            }
            if (apeData.total_ape_records !== undefined && apeData.total_ape_records !== null) {
                recordsWithApe = Number(apeData.total_ape_records) || 0;
                console.log('APE 적용 레코드 수:', recordsWithApe);
            }
            
            const totalRecords = Number(data.total_records) || 0;
            const apeUsageRate = totalRecords > 0 ? ((recordsWithApe / totalRecords) * 100) : 0;
            
            // 실제 개선 효과를 퍼센트 기준으로 분류
            let improvementRanges;
            let successfulImprovements = 0;
            
            if (recordsWithApe > 0) {
                // 실제 API에서 개별 레코드의 개선도를 받아와서 분류
                improvementRanges = await calculateRealImprovementDistribution();
                
                // 성공적인 개선 사례 계산 (2% 이상 개선)
                successfulImprovements = improvementRanges.slice(3).reduce((sum, range) => sum + range.count, 0);
            } else {
                improvementRanges = [
                    { 
                        range: '데이터없음', 
                        count: 1, 
                        color: '#6b7280', // Gray 500
                        description: '데이터 없음'
                    }
                ];
            }
            
            // APE 성공률 계산 (2% 이상 개선을 성공으로 간주)
            const successRate = recordsWithApe > 0 ? ((successfulImprovements / recordsWithApe) * 100).toFixed(1) : '0';
            
            // 품질등급 상승률 계산 (API에서 가져오기) - 안전한 숫자 변환
            const meaningfulImprovementRateNum = Number(apeData.meaningful_improvement_rate) || 0;
            const meaningfulImprovementRate = meaningfulImprovementRateNum.toFixed(1);
            
            console.log('품질등급 상승률:', meaningfulImprovementRate);
            
            // Q-Score와 품질등급 개선도 (적절한 스케일 적용) - 안전한 숫자 변환
            const qScoreImprovementNum = Number(apeData.avg_q_score_improvement) || 0;
            const qScoreImprovement = qScoreImprovementNum !== 0 ? (qScoreImprovementNum) : 0.8; // 10배로 적절한 스케일 유지
            const qualityGradeImprovement = meaningfulImprovementRateNum / 100; // 백분율을 실제 등급 변화로 변환 (예: 30% → 0.3등급)
            
            console.log('Q-Score 개선도:', qScoreImprovement);
            console.log('품질등급 개선도:', qualityGradeImprovement);
            
            return `
                <div class="chart-grid">
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">${avgGembaImprovement.toFixed(1)}</div>
                        <div class="chart-stat-label">GEMBA<br>평균 개선도</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">${avgCometImprovement.toFixed(1)}%</div>
                        <div class="chart-stat-label">COMET<br>평균 개선도</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">${avgCosineImprovement.toFixed(1)}%</div>
                        <div class="chart-stat-label">COSINE<br>평균 개선도</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">${recordsWithApe.toLocaleString()}</div>
                        <div class="chart-stat-label">편집 적용<br>문장</div>
                    </div>
                    <div class="chart-stat">
                        <div class="chart-stat-value" style="font-size: 24px;">${meaningfulImprovementRate}%</div>
                        <div class="chart-stat-label">품질등급<br>상승률</div>
                    </div>
                </div>
                
                <!-- 메트릭별 품질등급 상승률 비교 차트 -->
                <div class="chart-container" style="margin-bottom: 24px;">
                    <h3 style="margin-bottom: 16px; color: var(--text-primary); text-align: center;"></h3>
                    <div class="metrics-comparison-chart">
                        ${generateMetricsComparisonChart(
                            Number(avgGembaImprovement) || 0, 
                            Number(avgCometImprovement) || 0, 
                            Number(avgCosineImprovement) || 0, 
                            Number(qScoreImprovement) || 0.8, 
                            Number(qualityGradeImprovement) || 0.3
                        )}
                    </div>
                </div>
            `;
        }

        // 실제 APE 개선도 분포를 계산하는 함수
        async function calculateRealImprovementDistribution() {
            try {
                // APE가 적용된 레코드만 가져오기
                const response = await fetch(`${API_BASE}/records?has_ape=true&limit=10000`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const recordsData = await response.json();
                
                // APE가 적용된 레코드들
                const apeRecords = recordsData.records;
                
                console.log(`APE 레코드 수: ${apeRecords.length}`); // 디버깅용
                
                // 개선도 분류 카운터 초기화
                const improvementCounts = {
                    deterioration: 0,    // <0%
                    noChange: 0,         // 0%
                    minimal: 0,          // 0-2%
                    small: 0,            // 2-5%
                    medium: 0,           // 5-10%
                    large: 0             // ≥10%
                };
                
                // 각 레코드의 개선도 계산 및 분류
                apeRecords.forEach(record => {
                    // COMET 점수 기준으로 개선도 계산 (가장 신뢰할 만한 메트릭)
                    const originalComet = record.comet || 0;
                    const deltaComet = record.delta_comet || 0;
                    
                    if (originalComet > 0) {
                        const improvementPercent = (deltaComet / originalComet) * 100;
                        
                        console.log(`Record ${record.key}: ${improvementPercent.toFixed(2)}%`); // 디버깅용
                        
                        if (improvementPercent < 0) {
                            improvementCounts.deterioration++;
                        } else if (improvementPercent === 0) {
                            improvementCounts.noChange++;
                        } else if (improvementPercent <= 2) {
                            improvementCounts.minimal++;
                        } else if (improvementPercent <= 5) {
                            improvementCounts.small++;
                        } else if (improvementPercent <= 10) {
                            improvementCounts.medium++;
                        } else {
                            improvementCounts.large++;
                        }
                    } else {
                        // 원본 점수가 0인 경우 변화없음으로 분류
                        improvementCounts.noChange++;
                    }
                });
                

                
                return [
                    { 
                        range: '악화 (<0%)', 
                        count: improvementCounts.deterioration,
                        color: '#dc2626', // Red 600
                        description: '번역 품질이 오히려 악화'
                    },
                    { 
                        range: '변화없음 (0%)', 
                        count: improvementCounts.noChange,
                        color: '#6b7280', // Gray 500
                        description: '개선 효과 없음'
                    },
                    { 
                        range: '미미 (0-2%)', 
                        count: improvementCounts.minimal,
                        color: '#f59e0b', // Amber 500
                        description: '매우 작은 개선'
                    },
                    { 
                        range: '소폭 (2-5%)', 
                        count: improvementCounts.small,
                        color: '#3b82f6', // Blue 500
                        description: '눈에 띄는 개선'
                    },
                    { 
                        range: '중간 (5-10%)', 
                        count: improvementCounts.medium,
                        color: '#10b981', // Emerald 500
                        description: '상당한 품질 향상'
                    },
                    { 
                        range: '큰개선 (≥10%)', 
                        count: improvementCounts.large,
                        color: '#059669', // Emerald 600
                        description: '매우 큰 품질 향상'
                    }
                ];
                
            } catch (error) {
                console.error('실제 개선도 분포 계산 실패:', error);
                // 오류 시 기본값 반환
                return [
                    { 
                        range: '데이터 로드 실패', 
                        count: 1, 
                        color: '#6b7280',
                        description: '데이터를 불러올 수 없음'
                    }
                ];
            }
        }

        function createRadarChart(improvements) {
            const labels = ['GEMBA', 'COMET', 'COS', 'Q-Score', '품질등급'];
            const centerX = 200;
            const centerY = 200;
            const maxRadius = 150;
            const angleStep = (2 * Math.PI) / 5;

            const maxValues = [15, 10, 10, 1, 50]; // GEMBA: 15, COMET: 10%, COS: 10%, Q-Score: 1 (적절한 스케일), 품질등급: 100%

            const normalizedValues = improvements.map((val, index) => {
                // 완전히 안전한 숫자 처리
                const safeVal = (val === null || val === undefined || isNaN(val)) ? 0 : Math.abs(Number(val));
                const maxVal = maxValues[index] || 1; // 0으로 나누기 방지
                return Math.min(safeVal / maxVal * maxRadius, maxRadius);
            });
            
            let svgContent = `
                <svg class="radar-svg" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
                    <!-- 배경 격자 -->
                    <g class="radar-grid-group">
            `;
            
            for (let i = 1; i <= 5; i++) {
                const radius = (maxRadius / 5) * i;
                svgContent += `<circle cx="${centerX}" cy="${centerY}" r="${radius}" class="radar-grid"/>`;
            }
            
            for (let i = 0; i < 5; i++) {
                const angle = i * angleStep - Math.PI / 2; 
                const endX = centerX + Math.cos(angle) * maxRadius;
                const endY = centerY + Math.sin(angle) * maxRadius;
                svgContent += `<line x1="${centerX}" y1="${centerY}" x2="${endX}" y2="${endY}" class="radar-axis"/>`;
            }
            
            svgContent += `</g>`;
            
            let polygonPoints = '';
            for (let i = 0; i < 5; i++) {
                const angle = i * angleStep - Math.PI / 2;
                const radius = normalizedValues[i];
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                polygonPoints += `${x},${y} `;
            }
            
            svgContent += `<polygon points="${polygonPoints}" class="radar-polygon"/>`;
            
            for (let i = 0; i < 5; i++) {
                const angle = i * angleStep - Math.PI / 2;
                const radius = normalizedValues[i];
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                svgContent += `<circle cx="${x}" cy="${y}" r="4" class="radar-point"/>`;
            }
            
            for (let i = 0; i < 5; i++) {
                const angle = i * angleStep - Math.PI / 2;
                const labelRadius = maxRadius + 25;
                const x = centerX + Math.cos(angle) * labelRadius;
                const y = centerY + Math.sin(angle) * labelRadius;
                
                svgContent += `<text x="${x}" y="${y}" class="radar-label">${labels[i]}</text>`;
                
                
                const maxLabelY = y + 20; 
                const maxValueText = i === 3 ? '(최대 2.0)' : `(최대 ${maxValues[i]}${i >= 1 && i <= 2 ? '%' : i === 4 ? '%' : ''})`;
                svgContent += `<text x="${x}" y="${maxLabelY}" class="radar-max-label" style="font-size: 10px; fill: var(--text-muted); text-anchor: middle;">${maxValueText}</text>`;
            }
            
            svgContent += `</svg>`;
            
            svgContent += `
                <div style="margin-top: 16px; padding: 12px; background: var(--accent-bg); border-radius: 8px; font-size: 11px; color: var(--text-muted);">
                    <strong>스케일 참고:</strong> Q-score는 여러 품질 지표를 정규화하여 통합한 종합 번역 품질 점수입니다 (-1~1). 
                </div>
            `;
            
            return svgContent;
        }

        // 메트릭별 개선도 비교 차트 생성 - SVG 레이더 차트
        function generateMetricsComparisonChart(gembaImprovement, cometImprovement, cosineImprovement, qScoreImprovement = 0.8, qualityGradeImprovement = 0.3) {
            // 안전한 숫자 변환 함수
            function safeNumber(value, defaultValue = 0) {
                if (value === null || value === undefined || value === '') return defaultValue;
                const num = Number(value);
                return Number.isFinite(num) ? num : defaultValue;
            }
            
            // 개선도 배열 생성 (완전히 안전한 처리)
            const improvements = [
                safeNumber(gembaImprovement, 0),
                safeNumber(cometImprovement, 0),
                safeNumber(cosineImprovement, 0),
                safeNumber(qScoreImprovement, 0.8),
                safeNumber(qualityGradeImprovement, 0.3) * 20 // 등급을 퍼센트로 변환
            ];
            
            return `
                <div class="radar-chart-container">
                    <!-- 제목과 설명 -->
                    <div style="text-align: center; margin-bottom: 16px;">
                        <h4 style="margin: 0 0 8px 0; color: var(--text-primary); font-size: 16px;">번역 수정 전후 비교</h4>
                        <p style="margin: 0; color: var(--text-muted); font-size: 12px;">중점(수정 전)을 기준으로 각 매트릭의 개선도를 표시</p>
                    </div>
                    
                    <!-- SVG 레이더 차트 -->
                    ${createRadarChart(improvements)}
                </div>
            `;
        }

        // 이제 Chart.js 관련 함수들을 제거하고 showStatsChart에서도 수정이 필요합니다

        // 툴팁 기능이 있는 도넛차트 생성 - 깔끔한 2D 모던 디자인 (간격 있음)
        function generateDonutChartWithTooltip(data, total, chartId, comparisonData = null) {
            // 빈 데이터 처리
            if (!data || data.length === 0 || total === 0) {
                return `
                    <circle cx="100" cy="100" r="65" fill="none" stroke="#e5e7eb" stroke-width="20" opacity="0.3"/>
                    <text x="100" y="100" text-anchor="middle" dy=".3em" fill="var(--text-muted)" 
                          font-size="13" font-weight="500">데이터 없음</text>`;
            }
            
            let cumulativeAngle = 0;
            const radius = 65;
            const strokeWidth = 18; // 조금 더 얇게
            const centerX = 100;
            const centerY = 100;
            const gapAngle = 2; // 세그먼트 간 간격 (도 단위)
            
            const segments = data.filter(item => item.value > 0).map((item, index) => {
                const segmentAngle = (item.value / total) * 360 - gapAngle; // 간격만큼 빼기
                const startAngle = cumulativeAngle + (index > 0 ? gapAngle : 0); // 첫 번째 제외하고 간격 추가
                const endAngle = startAngle + segmentAngle;
                
                // 원호의 시작점과 끝점 계산
                const x1 = centerX + radius * Math.cos((startAngle - 90) * Math.PI / 180);
                const y1 = centerY + radius * Math.sin((startAngle - 90) * Math.PI / 180);
                const x2 = centerX + radius * Math.cos((endAngle - 90) * Math.PI / 180);
                const y2 = centerY + radius * Math.sin((endAngle - 90) * Math.PI / 180);
                
                const largeArcFlag = segmentAngle > 180 ? 1 : 0;
                
                // SVG path로 원호 생성 (stroke 기반)
                const pathData = `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`;
                
                cumulativeAngle = endAngle + gapAngle; // 다음 세그먼트를 위해 간격 추가
                
                // 툴팁 내용 생성
                let tooltipContent = '';
                
                if (comparisonData && chartId === 'after') {
                    // 비교 데이터가 있는 경우 (after 차트에서만)
                    const comparison = comparisonData.find(c => c.label === item.label);
                    if (comparison) {
                        const change = comparison.afterValue - comparison.beforeValue;
                        const changePercent = comparison.beforeValue > 0 ? 
                            ((change / comparison.beforeValue) * 100) : 0;
                        const changeIcon = change > 0 ? '↗' : change < 0 ? '↘' : '➖';
                        const changeColor = change > 0 ? '#22c55e' : change < 0 ? '#ef4444' : '#6b7280';
                        
                        tooltipContent = `<div style="font-weight: 600; margin-bottom: 8px; color: ${item.color}; font-size: 15px;">${item.label}</div><div style="margin-bottom: 6px; font-size: 14px;"><span style="font-weight: 600;">${item.value}건</span> (${(item.value/total*100).toFixed(1)}%)</div><div style="border-top: 1px solid rgba(255,255,255,0.15); margin-top: 10px; padding-top: 10px;"><div style="color: #cbd5e1; font-size: 12px; margin-bottom: 4px;">변화량</div><div style="color: ${changeColor}; font-weight: 600; font-size: 14px;">${changeIcon} ${comparison.beforeValue}건 → ${comparison.afterValue}건</div><div style="color: ${changeColor}; font-size: 12px; margin-top: 2px;">${change >= 0 ? '+' : ''}${change}건 ${changePercent !== 0 ? `(${changePercent > 0 ? '+' : ''}${changePercent.toFixed(1)}%)` : ''}</div></div>`;
                    } else {
                        tooltipContent = `<div style="font-weight: 600; margin-bottom: 8px; color: ${item.color}; font-size: 15px;">${item.label}</div><div style="font-size: 14px;"><span style="font-weight: 600;">${item.value}건</span> (${(item.value/total*100).toFixed(1)}%)</div>`;
                    }
                } else {
                    // 기본 툴팁 (before 차트)
                    tooltipContent = `<div style="font-weight: 600; margin-bottom: 8px; color: ${item.color}; font-size: 15px;">${item.label}</div><div style="font-size: 14px;"><span style="font-weight: 600;">${item.value}건</span> (${(item.value/total*100).toFixed(1)}%)</div>`;
                }
                
                return `
                    <path 
                        d="${pathData}" 
                        fill="none"
                        stroke="${item.color}" 
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                        style="cursor: pointer; transition: all 0.3s ease; opacity: 0.9;"
                        data-tip="${encodeURIComponent(tooltipContent)}"
                        data-chart-id="${chartId}"
                        data-color="${item.color}"
                    />
                `;
            }).join('');
            
            return segments;
        }
        
        // 도넛차트 툴팁 초기화 함수 - 심플한 2D 인터랙션 (간격 적용)
        function initDonutTooltips(rootEl) {
            rootEl.querySelectorAll('.donut-chart-wrapper').forEach(wrapper => {
                const chartId = wrapper.querySelector('path[data-chart-id]')?.dataset.chartId;
                if (!chartId) return;
                
                const tipBox = wrapper.querySelector(`#donut-tooltip-${chartId}`);
                if (!tipBox) return;
                
                wrapper.querySelectorAll('path[data-tip]').forEach(path => {
                    const color = path.dataset.color;
                    
                    path.addEventListener('pointerenter', e => {
                        // 툴팁 내용 설정
                        const tooltipContent = decodeURIComponent(path.dataset.tip);
                        tipBox.innerHTML = tooltipContent;
                        tipBox.style.opacity = '1';
                        tipBox.style.transform = 'translateY(0)';
                        tipBox.style.visibility = 'visible';
                        
                        // 심플한 호버 효과 - 두께만 증가 (간격 고려)
                        path.style.strokeWidth = '22'; // 원래 18에서 22로
                        path.style.opacity = '1';
                        
                        // 다른 세그먼트들 약간 흐리게
                        wrapper.querySelectorAll('path[data-tip]').forEach(otherPath => {
                            if (otherPath !== path) {
                                otherPath.style.opacity = '0.4';
                            }
                        });
                        
                        // 초기 위치 설정
                        updateTooltipPositionNew(e, wrapper, tipBox);
                    });
                    
                    path.addEventListener('pointermove', e => {
                        if (tipBox.style.opacity === '1') {
                            updateTooltipPositionNew(e, wrapper, tipBox);
                        }
                    });
                    
                    path.addEventListener('pointerleave', () => {
                        tipBox.style.opacity = '0';
                        tipBox.style.transform = 'translateY(-8px)';
                        tipBox.style.visibility = 'hidden';
                        
                        // 호버 효과 제거
                        path.style.strokeWidth = '18'; // 원래 크기로
                        path.style.opacity = '0.9';
                        
                        // 모든 세그먼트들 원상복구
                        wrapper.querySelectorAll('path[data-tip]').forEach(otherPath => {
                            otherPath.style.opacity = '0.9';
                        });
                    });
                });
            });
        }
        
        // 새로운 툴팁 위치 업데이트 함수
        function updateTooltipPositionNew(event, wrapper, tipBox) {
            const rect = wrapper.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // 툴팁이 차트 영역을 벗어나지 않도록 조정
            let tooltipX = x + 12;
            let tooltipY = y - 10;
            
            const tooltipRect = tipBox.getBoundingClientRect();
            const wrapperWidth = rect.width;
            const wrapperHeight = rect.height;
            
            // 오른쪽 경계 체크
            if (tooltipX + tooltipRect.width > wrapperWidth) {
                tooltipX = x - tooltipRect.width - 12;
            }
            
            // 위쪽 경계 체크
            if (tooltipY < 0) {
                tooltipY = y + 20;
            }
            
            // 아래쪽 경계 체크
            if (tooltipY + tooltipRect.height > wrapperHeight) {
                tooltipY = wrapperHeight - tooltipRect.height - 10;
            }
            
            tipBox.style.left = `${tooltipX}px`;
            tipBox.style.top = `${tooltipY}px`;
        }

        function closeStatsModal() {
            const modal = document.getElementById('statsModal');
            modal.classList.remove('show');
            
            // Chart.js 인스턴스 정리
            if (window.__radarChart) {
                window.__radarChart.destroy();
                window.__radarChart = null;
            }
        }

        // 모달 외부 클릭시 닫기
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('statsModal');
            if (event.target === modal) {
                closeStatsModal();
            }
        });

        // 역번역 기반 원문 개선 제안 함수들
        async function suggestSourceImprovement(recordKey, originalSource, apeTranslation) {
            const modal = document.getElementById('sourceImprovementModal');
            const originalText = document.getElementById('originalSourceText');
            const improvedText = document.getElementById('improvedSourceText');
            const reasonText = document.getElementById('improvementReason');
            
            // 모달 표시 및 원문 설정
            originalText.textContent = originalSource;
            modal.classList.add('show');
            
            try {
                // GPT API를 통한 원문 개선 제안
                const backTranslationResult = await performBackTranslation(recordKey, originalSource, apeTranslation);
                
                // 개선 제안 표시
                improvedText.innerHTML = `
                    <strong>개선된 원문:</strong><br>
                    ${backTranslationResult.improvedSource}
                `;
                
                reasonText.innerHTML = `
                    <strong>개선 근거:</strong><br>
                    ${backTranslationResult.reason.replace(/\n/g, '<br>')}
                `;
                
            } catch (error) {
                console.error('원문 개선 제안 실패:', error);
                improvedText.innerHTML = `
                    <div style="color: var(--danger-color);">
                        ❌ 원문 개선 제안을 생성하는 중 오류가 발생했습니다.<br>
                        ${error.message}
                    </div>
                `;
                reasonText.innerHTML = `
                    <div style="color: var(--text-muted);">
                        원문 개선 분석을 완료할 수 없습니다. 잠시 후 다시 시도해주세요.
                    </div>
                `;
            }
        }

        async function performBackTranslation(key, originalSource, apeTranslation) {
            try {
                // Python FastAPI 엔드포인트 호출
                const response = await fetch(`${API_BASE}/source-improvement/${key}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                return {
                    improvedSource: data.improvement_suggestion.improved_text || "개선된 텍스트를 생성할 수 없습니다.",
                    reason: data.improvement_suggestion.analysis || "분석 정보를 가져올 수 없습니다."
                };
                
            } catch (error) {
                console.error('원문 개선 제안 실패:', error);
                throw error; // 에러를 다시 던져서 상위에서 처리
            }
        }

        // 다른 수정 제안을 받는 함수
        async function getAlternativeEdit(key, originalSource, mtText, tag) {
            try {
                // 로딩 표시
                const loadingHTML = `
                    <div style="
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: var(--card-bg);
                        border: 1px solid var(--border-color);
                        border-radius: 8px;
                        padding: 16px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                        z-index: 1000;
                        max-width: 400px;
                    " id="alternative-loading">
                        <div class="loading">
                            <div class="spinner"></div>
                            수정 제안 생성 중...
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', loadingHTML);

                // API 호출
                const response = await fetch(`${API_BASE}/alternative-edit/${key}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                
                // 로딩 제거
                const loadingEl = document.getElementById('alternative-loading');
                if (loadingEl) loadingEl.remove();

                // 다른 수정 제안 표시
                showAlternativeEdit(data);

            } catch (error) {
                console.error('다른 수정 제안 실패:', error);
                
                // 로딩 제거
                const loadingEl = document.getElementById('alternative-loading');
                if (loadingEl) loadingEl.remove();
                
                // 에러 메시지 표시
                const errorHTML = `
                    <div style="
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: var(--danger-color);
                        color: white;
                        border-radius: 8px;
                        padding: 16px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                        z-index: 1000;
                        max-width: 400px;
                    " id="alternative-error">
                        ❌ 다른 수정 제안을 생성할 수 없습니다.<br>
                        ${error.message}
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', errorHTML);
                
                // 3초 후 자동 제거
                setTimeout(() => {
                    const errorEl = document.getElementById('alternative-error');
                    if (errorEl) errorEl.remove();
                }, 3000);
            }
        }

        function showAlternativeEdit(data) {
            const modalHTML = `
                <div style="
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: var(--card-bg);
                    border: 1px solid var(--border-color);
                    border-radius: 12px;
                    padding: 0;
                    max-width: 600px;
                    width: 90%;
                    max-height: 70vh;
                    overflow: hidden;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
                    z-index: 1001;
                    animation: modalSlideIn 0.3s ease-out;
                " id="alternative-edit-modal">
                    <div style="
                        background: linear-gradient(135deg, #10b981, #34d399);
                        color: white;
                        padding: 20px;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <div style="font-size: 18px; font-weight: 700;">
                            새로운 수정 제안
                        </div>
                        <button onclick="closeAlternativeModal()" style="
                            background: rgba(255, 255, 255, 0.2);
                            border: none;
                            color: white;
                            width: 32px;
                            height: 32px;
                            border-radius: 50%;
                            cursor: pointer;
                            font-size: 16px;
                        ">×</button>
                    </div>
                    <div style="padding: 20px; overflow-y: auto; max-height: 50vh;">
                        <div style="margin-bottom: 16px;">
                            <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 6px;">기존 기계번역</div>
                            <div style="
                                background: rgba(239, 68, 68, 0.1);
                                border-left: 3px solid var(--danger-color);
                                padding: 12px;
                                border-radius: 6px;
                                font-size: 14px;
                            ">${data.original_mt}</div>
                        </div>
                        
                        <div style="margin-bottom: 16px;">
                            <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 6px;">새로운 수정 제안</div>
                            <div style="
                                background: rgba(0, 208, 132, 0.1);
                                border-left: 3px solid var(--success-color);
                                padding: 12px;
                                border-radius: 6px;
                                font-size: 14px;
                                font-weight: 500;
                            ">${data.alternative_edit}</div>
                        </div>
                        
                        <div style="font-size: 11px; color: var(--text-muted); text-align: center; padding-top: 16px; border-top: 1px solid var(--border-color);">
                            이 제안은 더 높은 창의성으로 생성되었습니다. 
                        </div>
                    </div>
                </div>
                
                <div style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.6);
                    z-index: 1000;
                " id="alternative-modal-backdrop" onclick="closeAlternativeModal()"></div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 다른 수정 제안 모달 닫기
        function closeAlternativeModal() {
            const modal = document.getElementById('alternative-edit-modal');
            const backdrop = document.getElementById('alternative-modal-backdrop');
            if (modal) modal.remove();
            if (backdrop) backdrop.remove();
        }

        function closeSourceImprovementModal() {
            const modal = document.getElementById('sourceImprovementModal');
            modal.classList.remove('show');
        }

        // 모달 외부 클릭 시 닫기
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('sourceImprovementModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeSourceImprovementModal();
                }
            });
        });
    </script>
</body>
</html>